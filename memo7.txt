@file:OptIn(ExperimentalMaterial3Api::class, ExperimentalPagerApi::class)

package com.example.taskun_app

import android.app.DatePickerDialog
import android.app.TimePickerDialog
import android.content.ContentValues.TAG
import android.content.Context
import android.graphics.Bitmap
import android.graphics.BitmapFactory
import android.net.Uri
import android.os.Bundle
import android.util.Base64
import android.util.Log
import androidx.activity.ComponentActivity
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.compose.setContent
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.animation.animateContentSize
import androidx.compose.foundation.BorderStroke
import androidx.compose.foundation.Image
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.grid.GridCells
import androidx.compose.foundation.lazy.grid.LazyVerticalGrid
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Add
import androidx.compose.material.icons.filled.ArrowBack
import androidx.compose.material.icons.filled.ArrowForward
import androidx.compose.material.icons.filled.ExitToApp
import androidx.compose.material.icons.filled.Info
import androidx.compose.material.icons.filled.List
import androidx.compose.material.icons.filled.Person
import androidx.compose.material3.*
import androidx.compose.material3.SnackbarHostState
import androidx.compose.material3.SnackbarHost
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.asImageBitmap
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.input.ImeAction
import androidx.compose.ui.text.input.PasswordVisualTransformation
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProvider
import androidx.lifecycle.viewModelScope
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavHostController
import androidx.navigation.compose.NavHost
import androidx.navigation.compose.composable
import androidx.navigation.compose.currentBackStackEntryAsState
import androidx.navigation.compose.rememberNavController
import com.google.accompanist.pager.ExperimentalPagerApi
import com.google.gson.annotations.SerializedName
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import retrofit2.Retrofit
import retrofit2.converter.gson.GsonConverterFactory
import retrofit2.http.Body
import retrofit2.http.GET
import retrofit2.http.POST
import retrofit2.http.Path
import java.text.SimpleDateFormat
import java.util.*

// ─── DATA CLASSES & API DEFINITIONS ─────────────────────────────────────────────

data class RegisterRequest(val username: String, val password: String, val displayName: String)
data class RegisterResponse(val success: Boolean, val token: String?, val userId: Int?)

data class LoginRequest(val username: String, val password: String)
data class LoginResponse(val success: Boolean, val token: String?, val userId: Int?)

data class TaskCreationRequest(val userId: Int, val title: String, val description: String)
data class TaskCreationResponse(val success: Boolean, val taskId: Int?)

data class TaskJoinRequest(val userId: Int, val taskId: Int)
data class TaskJoinResponse(val success: Boolean)

data class TaskEditRequest(val taskId: Int, val title: String, val description: String)
data class TaskEditResponse(val success: Boolean)

data class TaskCompleteRequest(val taskId: Int)
data class TaskCompleteResponse(val success: Boolean)

data class TaskData(
    @SerializedName("id") val id: Int,
    @SerializedName("title") val title: String,
    @SerializedName("description") val description: String,
    @SerializedName("created_at") val createdAt: String,
    @SerializedName("creatorDisplayName") val creatorDisplayName: String,
    @SerializedName("creatorProfileImage") val creatorProfileImage: String?,
    @SerializedName("creatorId") val creatorId: Int,
    @SerializedName("status") val status: String
)
data class TaskListResponse(val success: Boolean, val tasks: List<TaskData>)

data class ProfileUpdateRequest(val userId: Int, val displayName: String, val description: String, val profileImageBase64: String?)
data class ProfileUpdateResponse(val success: Boolean)
data class ProfileDataResponse(val success: Boolean, val displayName: String, val description: String, val profileImageBase64: String?)

data class ScheduleAddRequest(val taskId: Int, val scheduledDate: String, val schedule: String, val userId: Int)
data class ScheduleAddResponse(val success: Boolean, val scheduleId: Int?)

data class ScheduleEditRequest(val scheduleId: Int, val scheduledDate: String, val schedule: String)
data class ScheduleEditResponse(val success: Boolean)

data class ScheduleDeleteRequest(val scheduleId: Int)
data class ScheduleDeleteResponse(val success: Boolean)

data class ScheduleData(
    @SerializedName("id") val id: Int,
    @SerializedName("scheduled_date") val scheduledDate: String,
    @SerializedName("schedule_description") val scheduleDescription: String,
    @SerializedName("finalized") val finalized: Boolean,
    @SerializedName("registeredUserId") val registeredUserId: Int?,
    @SerializedName("registeredUserName") val registeredUserName: String?,
    @SerializedName("registeredUserProfileImage") val registeredUserProfileImage: String?
)
data class ScheduleListResponse(val success: Boolean, val schedules: List<ScheduleData>)

data class VoteRequest(val scheduleId: Int, val userId: Int)
data class VoteResponse(val success: Boolean, val voteCount: Int?)

data class VoteDetail(
    @SerializedName("userId") val userId: Int,
    @SerializedName("displayName") val displayName: String,
    @SerializedName("profileImageBase64") val profileImageBase64: String?
)
data class VoteDetailResponse(val success: Boolean, val details: List<VoteDetail>)

data class Participant(
    @SerializedName("userId") val userId: Int,
    @SerializedName("displayName") val displayName: String,
    @SerializedName("profileImageBase64") val profileImageBase64: String?
)
data class ParticipantListResponse(val success: Boolean, val participants: List<Participant>)

data class FinalizeRequest(val taskId: Int, val scheduleId: Int)
data class FinalizeResponse(val success: Boolean)

data class DateRange(val start: Date, val end: Date)

// ─── RETROFIT & SESSION MANAGER ───────────────────────────────────────────────

interface ApiService {
    @POST("register")
    suspend fun register(@Body request: RegisterRequest): RegisterResponse

    @POST("login")
    suspend fun login(@Body request: LoginRequest): LoginResponse

    @POST("tasks")
    suspend fun createTask(@Body request: TaskCreationRequest): TaskCreationResponse

    @POST("tasks/join")
    suspend fun joinTask(@Body request: TaskJoinRequest): TaskJoinResponse

    @GET("tasks")
    suspend fun getTasks(): TaskListResponse

    @POST("tasks/edit")
    suspend fun editTask(@Body request: TaskEditRequest): TaskEditResponse

    @POST("tasks/complete")
    suspend fun completeTask(@Body request: TaskCompleteRequest): TaskCompleteResponse

    @POST("profile")
    suspend fun updateProfile(@Body request: ProfileUpdateRequest): ProfileUpdateResponse

    @GET("profile/{userId}")
    suspend fun getProfile(@Path("userId") userId: Int): ProfileDataResponse

    @GET("tasks/schedule/{taskId}")
    suspend fun getSchedules(@Path("taskId") taskId: Int): ScheduleListResponse

    @POST("tasks/schedule")
    suspend fun addSchedule(@Body request: ScheduleAddRequest): ScheduleAddResponse

    @POST("tasks/schedule/edit")
    suspend fun editSchedule(@Body request: ScheduleEditRequest): ScheduleEditResponse

    @POST("tasks/schedule/delete")
    suspend fun deleteSchedule(@Body request: ScheduleDeleteRequest): ScheduleDeleteResponse

    @GET("tasks/schedule/votes/{scheduleId}")
    suspend fun getVotes(@Path("scheduleId") scheduleId: Int): VoteResponse

    @POST("tasks/schedule/vote")
    suspend fun voteSchedule(@Body request: VoteRequest): VoteResponse

    @GET("tasks/schedule/voteDetails/{scheduleId}")
    suspend fun getVoteDetails(@Path("scheduleId") scheduleId: Int): VoteDetailResponse

    @GET("tasks/participants/{taskId}")
    suspend fun getTaskParticipants(@Path("taskId") taskId: Int): ParticipantListResponse

    @POST("tasks/schedule/finalize")
    suspend fun finalizeSchedule(@Body request: FinalizeRequest): FinalizeResponse
}

object RetrofitClient {
    private const val BASE_URL = "http://172.18.104.114:3000/"
    val apiService: ApiService by lazy {
        Retrofit.Builder()
            .baseUrl(BASE_URL)
            .addConverterFactory(GsonConverterFactory.create())
            .build()
            .create(ApiService::class.java)
    }
}

class SessionManager(context: Context) {
    private val prefs = context.getSharedPreferences("taskun_prefs", Context.MODE_PRIVATE)
    companion object {
        private const val KEY_TOKEN = "key_token"
        private const val KEY_USER_ID = "key_user_id"
    }
    fun saveAuthToken(token: String) { prefs.edit().putString(KEY_TOKEN, token).apply() }
    fun fetchAuthToken(): String? = prefs.getString(KEY_TOKEN, null)
    fun saveUserId(userId: Int) { prefs.edit().putInt(KEY_USER_ID, userId).apply() }
    fun fetchUserId(): Int = prefs.getInt(KEY_USER_ID, -1)
    fun clearSession() { prefs.edit().remove(KEY_TOKEN).remove(KEY_USER_ID).apply() }
}

// ─── HELPER FUNCTIONS ───────────────────────────────────────────────────────────

fun decodeBase64ToBitmap(base64String: String): Bitmap? {
    return try {
        val decodedBytes = Base64.decode(base64String, Base64.DEFAULT)
        BitmapFactory.decodeByteArray(decodedBytes, 0, decodedBytes.size)
    } catch (e: Exception) {
        Log.e(TAG, "Error decoding base64", e)
        null
    }
}

fun combineDateTime(date: Date, timeStr: String): Date {
    val calendar = Calendar.getInstance().apply { time = date }
    val parts = timeStr.split(":")
    if (parts.size >= 2) {
        calendar.set(Calendar.HOUR_OF_DAY, parts[0].toInt())
        calendar.set(Calendar.MINUTE, parts[1].toInt())
        calendar.set(Calendar.SECOND, 0)
    }
    return calendar.time
}

fun formatDate(date: Date): String {
    return SimpleDateFormat("yyyy/MM/dd", Locale.getDefault()).format(date)
}

// ─── LIGHT THEME ───────────────────────────────────────────────

private val LightColorScheme = lightColorScheme(
    primary = Color(0xFF1976D2),
    onPrimary = Color.White,
    secondary = Color(0xFF90CAF9),
    onSecondary = Color.Black,
    background = Color.White,
    onBackground = Color.Black,
    surface = Color.White,
    onSurface = Color.Black
)

@Composable
fun LightTaskunTheme(content: @Composable () -> Unit) {
    MaterialTheme(
        colorScheme = LightColorScheme,
        typography = Typography(
            headlineLarge = TextStyle(fontSize = 30.sp, fontWeight = FontWeight.Bold),
            headlineMedium = TextStyle(fontSize = 24.sp, fontWeight = FontWeight.SemiBold),
            bodyLarge = TextStyle(fontSize = 18.sp),
            bodyMedium = TextStyle(fontSize = 16.sp)
        ),
        shapes = Shapes(
            small = RoundedCornerShape(8.dp),
            medium = RoundedCornerShape(12.dp),
            large = RoundedCornerShape(16.dp)
        ),
        content = content
    )
}

// ─── 共通コンポーザブル：プロフィール画像 ─────────────────────────

@Composable
fun ProfileImage(base64String: String, modifier: Modifier = Modifier) {
    val bitmap = remember(base64String) { decodeBase64ToBitmap(base64String) }
    if (bitmap != null) {
        Image(
            bitmap = bitmap.asImageBitmap(),
            contentDescription = "Profile Image",
            modifier = modifier
                .clip(CircleShape)
                .border(2.dp, LightColorScheme.primary, CircleShape),
            contentScale = ContentScale.Crop
        )
    } else {
        Icon(
            imageVector = Icons.Filled.Person,
            contentDescription = "Default Profile",
            modifier = modifier
        )
    }
}

@Composable
fun ProfileImagePreview(base64String: String) {
    if (base64String.isNotEmpty()) {
        ProfileImage(base64String, modifier = Modifier.size(100.dp))
    } else {
        Box(
            modifier = Modifier
                .size(100.dp)
                .clip(CircleShape)
                .border(2.dp, LightColorScheme.primary, CircleShape),
            contentAlignment = Alignment.Center
        ) {
            Icon(
                imageVector = Icons.Filled.Person,
                contentDescription = "Select Profile Image",
                modifier = Modifier.size(50.dp)
            )
        }
    }
}

// ─── 時刻選択ボタン ───────────────────────────────

@Composable
fun TimePickerButton(label: String, time: String, onTimeSelected: (String) -> Unit) {
    val context = LocalContext.current
    ElevatedButton(
        onClick = {
            val calendar = Calendar.getInstance()
            val hour = calendar.get(Calendar.HOUR_OF_DAY)
            val minute = calendar.get(Calendar.MINUTE)
            TimePickerDialog(context, { _, selectedHour, selectedMinute ->
                onTimeSelected(String.format("%02d:%02d", selectedHour, selectedMinute))
            }, hour, minute, true).show()
        },
        modifier = Modifier.fillMaxWidth()
    ) {
        Text("$label: $time")
    }
}

// ─── 改良カレンダー（左右の矢印付き） ─────────────────────────

@Composable
fun ImprovedCalendar(
    initialYear: Int = Calendar.getInstance().get(Calendar.YEAR),
    initialMonth: Int = Calendar.getInstance().get(Calendar.MONTH),
    selectedRange: DateRange?,
    onRangeSelected: (DateRange) -> Unit
) {
    var currentYear by remember { mutableStateOf(initialYear) }
    var currentMonth by remember { mutableStateOf(initialMonth) }
    var tempStartDate by remember { mutableStateOf<Date?>(null) }
    Column(
        modifier = Modifier
            .fillMaxWidth()
            .padding(8.dp)
            .background(
                brush = Brush.horizontalGradient(listOf(Color.White, LightColorScheme.background)),
                shape = RoundedCornerShape(12.dp)
            )
            .padding(8.dp)
    ) {
        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.SpaceBetween,
            verticalAlignment = Alignment.CenterVertically
        ) {
            IconButton(onClick = {
                val cal = Calendar.getInstance().apply { set(currentYear, currentMonth, 1) }
                cal.add(Calendar.MONTH, -1)
                currentYear = cal.get(Calendar.YEAR)
                currentMonth = cal.get(Calendar.MONTH)
            }) {
                Icon(Icons.Filled.ArrowBack, contentDescription = "前月")
            }
            Text(text = "$currentYear 年 ${currentMonth + 1}月", style = MaterialTheme.typography.headlineSmall)
            IconButton(onClick = {
                val cal = Calendar.getInstance().apply { set(currentYear, currentMonth, 1) }
                cal.add(Calendar.MONTH, 1)
                currentYear = cal.get(Calendar.YEAR)
                currentMonth = cal.get(Calendar.MONTH)
            }) {
                Icon(Icons.Filled.ArrowForward, contentDescription = "次月")
            }
        }
        val calendar = Calendar.getInstance().apply { set(currentYear, currentMonth, 1) }
        val daysInMonth = calendar.getActualMaximum(Calendar.DAY_OF_MONTH)
        val firstDayOfWeek = calendar.get(Calendar.DAY_OF_WEEK)
        val days = (1..daysInMonth).map { day ->
            calendar.apply { set(currentYear, currentMonth, day) }
            calendar.time
        }
        LazyVerticalGrid(
            columns = GridCells.Fixed(7),
            modifier = Modifier.height(250.dp)
        ) {
            items(firstDayOfWeek - 1) {
                Box(modifier = Modifier.aspectRatio(1f))
            }
            items(days.size) { index ->
                val day = days[index]
                val isSelected = selectedRange?.let { !day.before(it.start) && !day.after(it.end) } ?: false
                Box(
                    modifier = Modifier
                        .aspectRatio(1f)
                        .padding(2.dp)
                        .clickable {
                            if (tempStartDate == null) {
                                tempStartDate = day
                            } else {
                                val start = if (day.before(tempStartDate)) day else tempStartDate!!
                                val end = if (day.before(tempStartDate)) tempStartDate!! else day
                                onRangeSelected(DateRange(start, end))
                                tempStartDate = null
                            }
                        }
                        .background(
                            if (isSelected) LightColorScheme.primary.copy(alpha = 0.5f) else Color.Transparent,
                            shape = RoundedCornerShape(6.dp)
                        ),
                    contentAlignment = Alignment.Center
                ) {
                    Text(
                        text = SimpleDateFormat("d", Locale.getDefault()).format(day),
                        color = if (isSelected) Color.White else LightColorScheme.onBackground
                    )
                }
            }
        }
    }
}



// ─── 各種画面 ──────────────────────────────────────────────────────────────

@Composable
fun RegistrationScreen(navController: NavHostController, sessionManager: SessionManager, snackbarHostState: SnackbarHostState) {
    var username by remember { mutableStateOf("") }
    var password by remember { mutableStateOf("") }
    var displayName by remember { mutableStateOf("") }
    var isLoading by remember { mutableStateOf(false) }
    val coroutineScope = rememberCoroutineScope()
    Box(modifier = Modifier
        .fillMaxSize()
        .background(Color.White)) {
        Card(
            modifier = Modifier
                .fillMaxWidth()
                .padding(24.dp)
                .align(Alignment.Center)
                .animateContentSize(),
            shape = RoundedCornerShape(16.dp),
            elevation = CardDefaults.cardElevation(8.dp)
        ) {
            Column(modifier = Modifier
                .padding(24.dp)
                .verticalScroll(rememberScrollState())) {
                Text(text = "たすくん", style = MaterialTheme.typography.headlineLarge)
                Spacer(modifier = Modifier.height(16.dp))
                OutlinedTextField(
                    value = username,
                    onValueChange = { username = it },
                    label = { Text("ユーザーネーム") },
                    singleLine = true,
                    modifier = Modifier.fillMaxWidth(),
                    isError = username.isBlank()
                )
                if (username.isBlank()) {
                    Text("ユーザーネームは必須です", style = MaterialTheme.typography.labelSmall, color = Color.Red)
                }
                Spacer(modifier = Modifier.height(8.dp))
                OutlinedTextField(
                    value = password,
                    onValueChange = { password = it },
                    label = { Text("パスワード (6文字以上)") },
                    visualTransformation = PasswordVisualTransformation(),
                    singleLine = true,
                    modifier = Modifier.fillMaxWidth(),
                    keyboardOptions = KeyboardOptions(imeAction = ImeAction.Next),
                    isError = password.length < 6
                )
                if (password.length < 6) {
                    Text("パスワードは6文字以上必要です", style = MaterialTheme.typography.labelSmall, color = Color.Red)
                }
                Spacer(modifier = Modifier.height(8.dp))
                OutlinedTextField(
                    value = displayName,
                    onValueChange = { displayName = it },
                    label = { Text("表示名") },
                    singleLine = true,
                    modifier = Modifier.fillMaxWidth(),
                    isError = displayName.isBlank()
                )
                if (displayName.isBlank()) {
                    Text("表示名は必須です", style = MaterialTheme.typography.labelSmall, color = Color.Red)
                }
                Spacer(modifier = Modifier.height(16.dp))
                ElevatedButton(
                    onClick = {
                        if (username.isBlank() || password.length < 6 || displayName.isBlank()) {
                            coroutineScope.launch { snackbarHostState.showSnackbar("入力内容を確認してください。") }
                            return@ElevatedButton
                        }
                        isLoading = true
                        coroutineScope.launch {
                            try {
                                val response = RetrofitClient.apiService.register(RegisterRequest(username, password, displayName))
                                if (response.success && response.token != null && response.userId != null) {
                                    sessionManager.saveAuthToken(response.token)
                                    sessionManager.saveUserId(response.userId)
                                    navController.navigate("main") { popUpTo("register") { inclusive = true } }
                                } else {
                                    snackbarHostState.showSnackbar("登録に失敗しました。")
                                }
                            } catch (e: Exception) {
                                Log.e(TAG, "Registration error", e)
                                snackbarHostState.showSnackbar("サーバーエラーが発生しました。")
                            } finally {
                                isLoading = false
                            }
                        }
                    },
                    modifier = Modifier.fillMaxWidth(),
                    enabled = !isLoading
                ) {
                    Text("会員登録")
                }
                Spacer(modifier = Modifier.height(16.dp))
                Text(
                    text = "既に登録済みの方はこちら",
                    style = MaterialTheme.typography.bodyMedium,
                    color = LightColorScheme.primary,
                    modifier = Modifier.clickable { navController.navigate("login") { popUpTo("register") { inclusive = true } } }
                )
            }
        }
    }
}

@Composable
fun LoginScreen(navController: NavHostController, sessionManager: SessionManager, snackbarHostState: SnackbarHostState) {
    var username by remember { mutableStateOf("") }
    var password by remember { mutableStateOf("") }
    var isLoading by remember { mutableStateOf(false) }
    val coroutineScope = rememberCoroutineScope()
    Box(modifier = Modifier
        .fillMaxSize()
        .background(Color.White)) {
        Card(
            modifier = Modifier
                .fillMaxWidth()
                .padding(24.dp)
                .align(Alignment.Center)
                .animateContentSize(),
            shape = RoundedCornerShape(16.dp),
            elevation = CardDefaults.cardElevation(8.dp)
        ) {
            Column(modifier = Modifier
                .padding(24.dp)
                .verticalScroll(rememberScrollState())) {
                Text(text = "たすくん", style = MaterialTheme.typography.headlineLarge)
                Spacer(modifier = Modifier.height(16.dp))
                OutlinedTextField(
                    value = username,
                    onValueChange = { username = it },
                    label = { Text("ユーザーネーム") },
                    singleLine = true,
                    modifier = Modifier.fillMaxWidth()
                )
                Spacer(modifier = Modifier.height(8.dp))
                OutlinedTextField(
                    value = password,
                    onValueChange = { password = it },
                    label = { Text("パスワード") },
                    visualTransformation = PasswordVisualTransformation(),
                    singleLine = true,
                    modifier = Modifier.fillMaxWidth()
                )
                Spacer(modifier = Modifier.height(16.dp))
                ElevatedButton(
                    onClick = {
                        isLoading = true
                        coroutineScope.launch {
                            try {
                                val response = RetrofitClient.apiService.login(LoginRequest(username, password))
                                if (response.success && response.token != null && response.userId != null) {
                                    sessionManager.saveAuthToken(response.token)
                                    sessionManager.saveUserId(response.userId)
                                    navController.navigate("main") { popUpTo("login") { inclusive = true } }
                                } else {
                                    snackbarHostState.showSnackbar("ユーザ名またはパスワードが正しくありません。")
                                }
                            } catch (e: Exception) {
                                Log.e(TAG, "Login error", e)
                                snackbarHostState.showSnackbar("サーバーエラーが発生しました。")
                            } finally {
                                isLoading = false
                            }
                        }
                    },
                    modifier = Modifier.fillMaxWidth(),
                    enabled = !isLoading
                ) {
                    Text("ログイン")
                }
                Spacer(modifier = Modifier.height(16.dp))
                Text(
                    text = "新規登録していない人はこちら",
                    color = LightColorScheme.primary,
                    modifier = Modifier
                        .fillMaxWidth()
                        .clickable { navController.navigate("register") },
                    textAlign = androidx.compose.ui.text.style.TextAlign.Center
                )
            }
        }
    }
}



@Composable
fun MainScreen(userId: Int, sessionManager: SessionManager, outerNavController: NavHostController, snackbarHostState: SnackbarHostState) {
    val innerNavController = rememberNavController()
    Scaffold(
        topBar = {
            CenterAlignedTopAppBar(
                title = { Text("たすくん") },
                actions = {
                    IconButton(onClick = {
                        sessionManager.clearSession()
                        outerNavController.navigate("login") { popUpTo("main") { inclusive = true } }
                    }) {
                        Icon(Icons.Filled.ExitToApp, contentDescription = "Logout")
                    }
                },
                colors = TopAppBarDefaults.centerAlignedTopAppBarColors(containerColor = LightColorScheme.primary)
            )
        },
        bottomBar = { BottomNavigationBar(innerNavController) },
        snackbarHost = { SnackbarHost(hostState = snackbarHostState) },
        containerColor = LightColorScheme.background
    ) { innerPadding ->
        NavHost(navController = innerNavController, startDestination = "instruction", modifier = Modifier.padding(innerPadding)) {
            composable("instruction") { InstructionScreen(innerNavController) }
            composable("taskList") { TaskListScreen(innerNavController, userId, snackbarHostState) }
            composable("taskRegistration") { TaskRegistrationScreen(userId, snackbarHostState) }
            composable("profileRegistration") { ProfileRegistrationScreen(userId, snackbarHostState) }
            composable("profileView/{userId}") { backStackEntry ->
                val profileUserId = backStackEntry.arguments?.getString("userId")?.toInt() ?: 0
                UserProfileScreen(profileUserId, snackbarHostState)
            }
            composable("taskEdit/{taskId}") { backStackEntry ->
                val taskId = backStackEntry.arguments?.getString("taskId")?.toInt() ?: 0
                TaskEditScreen(taskId, innerNavController, snackbarHostState)
            }
            composable("scheduleEdit/{scheduleId}") { backStackEntry ->
                val scheduleId = backStackEntry.arguments?.getString("scheduleId")?.toInt() ?: 0
                ScheduleEditScreen(scheduleId, innerNavController, snackbarHostState)
            }
            composable("taskParticipants/{taskId}") { backStackEntry ->
                val taskId = backStackEntry.arguments?.getString("taskId")?.toInt() ?: 0
                TaskParticipantsScreen(taskId, innerNavController, snackbarHostState)
            }
            composable("taskScheduleManagement/{taskId}") { backStackEntry ->
                val taskId = backStackEntry.arguments?.getString("taskId")?.toInt() ?: 0
                TaskScheduleManagementScreen(taskId, innerNavController, sessionManager.fetchUserId(), snackbarHostState)
            }
        }
    }
}

sealed class Screen(val route: String, val label: String, val icon: @Composable () -> Unit) {
    object Instruction : Screen("instruction", "使い方", { Icon(Icons.Filled.Info, contentDescription = null) })
    object TaskList : Screen("taskList", "タスクリスト", { Icon(Icons.Filled.List, contentDescription = null) })
    object TaskRegistration : Screen("taskRegistration", "タスク登録", { Icon(Icons.Filled.Add, contentDescription = null) })
    object ProfileRegistration : Screen("profileRegistration", "プロフィール", { Icon(Icons.Filled.Person, contentDescription = null) })
}

@Composable
fun BottomNavigationBar(navController: NavHostController) {
    val items = listOf(Screen.Instruction, Screen.TaskList, Screen.TaskRegistration, Screen.ProfileRegistration)
    val navBackStackEntry by navController.currentBackStackEntryAsState()
    val currentRoute = navBackStackEntry?.destination?.route
    NavigationBar {
        items.forEach { screen ->
            NavigationBarItem(
                icon = screen.icon,
                label = { Text(screen.label) },
                selected = currentRoute?.startsWith(screen.route.substringBefore("/")) == true,
                onClick = {
                    navController.navigate(screen.route) {
                        popUpTo(navController.graph.startDestinationId) { saveState = true }
                        launchSingleTop = true
                        restoreState = true
                    }
                }
            )
        }
    }
}

@Composable
fun InstructionScreen(navController: NavHostController) {
    Box(modifier = Modifier
        .fillMaxSize()
        .background(Color.White),
        contentAlignment = Alignment.Center
    ) {
        Card(
            modifier = Modifier.padding(24.dp),
            shape = RoundedCornerShape(16.dp),
            elevation = CardDefaults.cardElevation(8.dp)
        ) {
            Column(modifier = Modifier.padding(24.dp), horizontalAlignment = Alignment.CenterHorizontally) {
                Text("使い方の説明", style = MaterialTheme.typography.headlineMedium)
                Spacer(modifier = Modifier.height(16.dp))
                Text(
                    "・タスク登録画面でタスクを作成し、スケジュール登録・投票で実施日時を決定します。\n" +
                            "・タスク一覧では、タスク作成者のプロフィールをタップすると詳細が見られます。\n" +
                            "・タスク編集、スケジュール管理、参加者一覧などの機能を実装しています。",
                    style = MaterialTheme.typography.bodyLarge,
                    textAlign = androidx.compose.ui.text.style.TextAlign.Center
                )
                Spacer(modifier = Modifier.height(24.dp))
                ElevatedButton(onClick = { navController.navigate("taskList") }, modifier = Modifier.fillMaxWidth()) {
                    Text("タスクリストへ進む")
                }
            }
        }
    }
}

// ─── タスクリスト画面（UI刷新版） ─────────────────────────

@Composable
fun TaskListScreen(
    navController: NavHostController,
    userId: Int,
    snackbarHostState: SnackbarHostState
) {
    var tasks by remember { mutableStateOf(listOf<TaskData>()) }
    var isLoading by remember { mutableStateOf(true) }
    var errorMessage by remember { mutableStateOf("") }
    var sortOrder by remember { mutableStateOf("新しい順") }
    var filterStatus by remember { mutableStateOf("全て") }
    var joinedTaskIds by remember { mutableStateOf(setOf<Int>()) }
    val coroutineScope = rememberCoroutineScope()

    LaunchedEffect(Unit) {
        while (true) {
            try {
                val response = RetrofitClient.apiService.getTasks()
                if (response.success) {
                    tasks = response.tasks
                    errorMessage = ""
                } else {
                    errorMessage = "タスク取得に失敗しました。"
                }
            } catch (e: Exception) {
                errorMessage = "サーバーに接続できません。"
                Log.e(TAG, "タスク取得エラー", e)
            } finally {
                isLoading = false
            }
            delay(5000)
        }
    }

    val filteredTasks = tasks.filter { task ->
        filterStatus == "全て" || task.status == filterStatus
    }.sortedByDescending { it.createdAt }.let {
        if (sortOrder == "古い順") it.reversed() else it
    }

    Column(modifier = Modifier
        .fillMaxSize()
        .background(LightColorScheme.background)
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(horizontal = 16.dp, vertical = 8.dp),
            horizontalArrangement = Arrangement.SpaceBetween
        ) {
            DropdownMenuBox(
                label = "並び順",
                options = listOf("新しい順", "古い順"),
                selectedOption = sortOrder
            ) { sortOrder = it }
            DropdownMenuBox(
                label = "ステータス",
                options = listOf("全て", "進行中", "完了済み"),
                selectedOption = filterStatus
            ) { filterStatus = it }
        }
        Spacer(modifier = Modifier.height(8.dp))
        if (isLoading) {
            Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
                CircularProgressIndicator()
            }
        } else {
            if (errorMessage.isNotEmpty()) {
                Text(
                    text = errorMessage,
                    modifier = Modifier.align(Alignment.CenterHorizontally),
                    color = Color.Red
                )
            } else {
                LazyColumn(
                    modifier = Modifier
                        .fillMaxSize()
                        .padding(horizontal = 16.dp)
                ) {
                    items(filteredTasks) { task ->
                        Card(
                            modifier = Modifier
                                .fillMaxWidth()
                                .padding(vertical = 8.dp)
                                .clickable { /* タスク詳細画面への遷移 */ },
                            shape = RoundedCornerShape(16.dp),
                            elevation = CardDefaults.cardElevation(8.dp),
                            colors = CardDefaults.cardColors(containerColor = Color.White)
                        ) {
                            Column(modifier = Modifier.padding(16.dp)) {
                                // プロフィール画像とユーザー名
                                Row(verticalAlignment = Alignment.CenterVertically) {
                                    if (task.creatorProfileImage != null) {
                                        ProfileImage(
                                            base64String = task.creatorProfileImage,
                                            modifier = Modifier
                                                .size(48.dp)
                                                .clip(CircleShape)
                                                .border(2.dp, LightColorScheme.primary, CircleShape)
                                        )
                                    } else {
                                        Icon(
                                            imageVector = Icons.Filled.Person,
                                            contentDescription = "Profile",
                                            modifier = Modifier.size(48.dp)
                                        )
                                    }
                                    Spacer(modifier = Modifier.width(8.dp))
                                    Text(
                                        text = task.creatorDisplayName,
                                        style = MaterialTheme.typography.titleMedium.copy(
                                            fontWeight = FontWeight.Bold,
                                            color = LightColorScheme.primary
                                        )
                                    )
                                }
                                Divider(modifier = Modifier.padding(vertical = 4.dp))
                                // タスク名
                                Text(
                                    text = "タスク名: ${task.title}",
                                    style = MaterialTheme.typography.titleLarge.copy(fontWeight = FontWeight.ExtraBold)
                                )
                                Divider(modifier = Modifier.padding(vertical = 4.dp))
                                // タスクの説明
                                Text("タスクの説明", style = MaterialTheme.typography.labelMedium)
                                Text(task.description, style = MaterialTheme.typography.bodyMedium)
                                Divider(modifier = Modifier.padding(vertical = 4.dp))
                                // 作成日時とステータス
                                Row(
                                    modifier = Modifier.fillMaxWidth(),
                                    horizontalArrangement = Arrangement.SpaceBetween
                                ) {
                                    Column {
                                        Text("作成日時", style = MaterialTheme.typography.labelSmall.copy(color = LightColorScheme.primary))
                                        Text(task.createdAt, style = MaterialTheme.typography.bodySmall, color = Color.Gray)
                                    }
                                    Column(horizontalAlignment = Alignment.End) {
                                        Text("ステータス", style = MaterialTheme.typography.labelSmall.copy(color = LightColorScheme.primary))
                                        Text(
                                            task.status,
                                            style = MaterialTheme.typography.bodySmall,
                                            color = if (task.status == "完了済み") Color(0xFF388E3C) else LightColorScheme.primary
                                        )
                                    }
                                }
                                Divider(modifier = Modifier.padding(vertical = 4.dp))
                                // タスク参加／管理ボタン
                                if (userId == task.creatorId) {
                                    Row(
                                        modifier = Modifier.fillMaxWidth(),
                                        horizontalArrangement = Arrangement.SpaceEvenly
                                    ) {
                                        ElevatedButton(onClick = { navController.navigate("taskEdit/${task.id}") }) {
                                            Text("タスク編集")
                                        }
                                        ElevatedButton(onClick = { navController.navigate("taskScheduleManagement/${task.id}") }) {
                                            Text("スケジュール管理")
                                        }
                                    }
                                } else {
                                    if (joinedTaskIds.contains(task.id)) {
                                        ElevatedButton(
                                            onClick = { navController.navigate("taskScheduleManagement/${task.id}") },
                                            modifier = Modifier.fillMaxWidth()
                                        ) {
                                            Text("参加済み")
                                        }
                                    } else {
                                        ElevatedButton(
                                            onClick = {
                                                coroutineScope.launch {
                                                    try {
                                                        val joinResponse = RetrofitClient.apiService.joinTask(
                                                            TaskJoinRequest(userId, task.id)
                                                        )
                                                        if (joinResponse.success) {
                                                            joinedTaskIds = joinedTaskIds + task.id
                                                            navController.navigate("taskScheduleManagement/${task.id}")
                                                        } else {
                                                            snackbarHostState.showSnackbar("タスク参加に失敗しました")
                                                        }
                                                    } catch (e: Exception) {
                                                        Log.e(TAG, "タスク参加処理でエラー", e)
                                                    }
                                                }
                                            },
                                            modifier = Modifier.fillMaxWidth()
                                        ) {
                                            Text("タスク参加")
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

@Composable
fun DropdownMenuBox(label: String, options: List<String>, selectedOption: String, onOptionSelected: (String) -> Unit) {
    var expanded by remember { mutableStateOf(false) }
    Box {
        OutlinedButton(onClick = { expanded = true }) {
            Text("$label: $selectedOption")
        }
        DropdownMenu(expanded = expanded, onDismissRequest = { expanded = false }) {
            options.forEach { option ->
                DropdownMenuItem(text = { Text(option) }, onClick = {
                    onOptionSelected(option)
                    expanded = false
                })
            }
        }
    }
}

@Composable
fun TaskRegistrationScreen(userId: Int, snackbarHostState: SnackbarHostState) {
    var title by remember { mutableStateOf("") }
    var description by remember { mutableStateOf("") }
    val coroutineScope = rememberCoroutineScope()
    Box(modifier = Modifier
        .fillMaxSize()
        .background(Color.White),
        contentAlignment = Alignment.Center
    ) {
        Card(
            modifier = Modifier
                .fillMaxWidth()
                .padding(24.dp),
            shape = RoundedCornerShape(16.dp),
            elevation = CardDefaults.cardElevation(8.dp)
        ) {
            Column(modifier = Modifier.padding(24.dp)) {
                OutlinedTextField(
                    value = title,
                    onValueChange = { title = it },
                    label = { Text("タスクタイトル（必須、最大50文字）") },
                    modifier = Modifier.fillMaxWidth(),
                    isError = title.isBlank() || title.length > 50
                )
                if (title.isBlank()) {
                    Text("タイトルは必須です", style = MaterialTheme.typography.labelSmall, color = Color.Red)
                } else if (title.length > 50) {
                    Text("タイトルは50文字以内", style = MaterialTheme.typography.labelSmall, color = Color.Red)
                }
                Spacer(modifier = Modifier.height(8.dp))
                OutlinedTextField(
                    value = description,
                    onValueChange = { description = it },
                    label = { Text("タスク説明（必須、最大200文字）") },
                    modifier = Modifier.fillMaxWidth(),
                    isError = description.isBlank() || description.length > 200
                )
                if (description.isBlank()) {
                    Text("説明は必須です", style = MaterialTheme.typography.labelSmall, color = Color.Red)
                } else if (description.length > 200) {
                    Text("説明は200文字以内", style = MaterialTheme.typography.labelSmall, color = Color.Red)
                }
                Spacer(modifier = Modifier.height(16.dp))
                ElevatedButton(onClick = {
                    coroutineScope.launch {
                        try {
                            if (title.isBlank() || description.isBlank()) {
                                snackbarHostState.showSnackbar("全項目を入力してください")
                            } else {
                                val response = RetrofitClient.apiService.createTask(TaskCreationRequest(userId, title, description))
                                if (response.success) {
                                    snackbarHostState.showSnackbar("タスク登録成功")
                                } else {
                                    snackbarHostState.showSnackbar("タスク登録失敗")
                                }
                            }
                        } catch (e: Exception) {
                            Log.e(TAG, "タスク登録エラー", e)
                            snackbarHostState.showSnackbar("サーバーエラー")
                        }
                    }
                }, modifier = Modifier.fillMaxWidth()) {
                    Text("タスク登録")
                }
            }
        }
    }
}

@Composable
fun ProfileRegistrationScreen(userId: Int, snackbarHostState: SnackbarHostState) {
    var displayName by remember { mutableStateOf("") }
    var description by remember { mutableStateOf("") }
    var profileImageBase64 by remember { mutableStateOf("") }
    var selectedImageUri by remember { mutableStateOf<Uri?>(null) }
    var isLoading by remember { mutableStateOf(true) }
    val context = LocalContext.current
    val coroutineScope = rememberCoroutineScope()

    LaunchedEffect(userId) {
        try {
            val response = RetrofitClient.apiService.getProfile(userId)
            if (response.success) {
                displayName = response.displayName ?:""
                description = response.description ?:""
                profileImageBase64 = response.profileImageBase64 ?: ""
            }
        } catch (e: Exception) {
            Log.e(TAG, "プロフィール取得エラー", e)
        } finally {
            isLoading = false
        }
    }

    if (isLoading) {
        Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) { CircularProgressIndicator() }
    } else {
        Box(modifier = Modifier
            .fillMaxSize()
            .background(Color.White),
            contentAlignment = Alignment.Center
        ) {
            Card(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(24.dp),
                shape = RoundedCornerShape(16.dp),
                elevation = CardDefaults.cardElevation(8.dp)
            ) {
                Column(modifier = Modifier.padding(24.dp)) {
                    ProfileImagePreview(profileImageBase64)
                    Spacer(modifier = Modifier.height(16.dp))
                    OutlinedTextField(
                        value = displayName,
                        onValueChange = { displayName = it },
                        label = { Text("表示名（必須）") },
                        modifier = Modifier.fillMaxWidth(),
                        isError = displayName.isBlank()
                    )
                    if (displayName.isBlank()) {
                        Text("表示名は必須です", style = MaterialTheme.typography.labelSmall, color = Color.Red)
                    }
                    Spacer(modifier = Modifier.height(8.dp))
                    OutlinedTextField(
                        value = description,
                        onValueChange = { description = it },
                        label = { Text("自己紹介") },
                        modifier = Modifier.fillMaxWidth()
                    )
                    Spacer(modifier = Modifier.height(8.dp))
                    val launcher = rememberLauncherForActivityResult(
                        contract = ActivityResultContracts.GetContent()
                    ) { uri: Uri? ->
                        if (uri != null) {
                            selectedImageUri = uri
                            try {
                                val inputStream = context.contentResolver.openInputStream(uri)
                                val bytes = inputStream?.readBytes()
                                if (bytes != null) {
                                    profileImageBase64 = Base64.encodeToString(bytes, Base64.NO_WRAP)
                                }
                            } catch (e: Exception) {
                                Log.e(TAG, "画像変換エラー", e)
                            }
                        }
                    }
                    ElevatedButton(onClick = { launcher.launch("image/*") }) {
                        Text("プロフィール画像を選択")
                    }
                    Spacer(modifier = Modifier.height(16.dp))
                    ElevatedButton(onClick = {
                        coroutineScope.launch {
                            try {
                                if (displayName.isBlank()) {
                                    snackbarHostState.showSnackbar("表示名は必須です")
                                } else {
                                    val response = RetrofitClient.apiService.updateProfile(
                                        ProfileUpdateRequest(userId, displayName, description, if (profileImageBase64.isNotEmpty()) profileImageBase64 else null)
                                    )
                                    if (response.success) {
                                        snackbarHostState.showSnackbar("プロフィール更新成功")
                                    } else {
                                        snackbarHostState.showSnackbar("プロフィール更新失敗")
                                    }
                                }
                            } catch (e: Exception) {
                                Log.e(TAG, "プロフィール更新エラー", e)
                                snackbarHostState.showSnackbar("サーバーエラー")
                            }
                        }
                    }, modifier = Modifier.fillMaxWidth()) {
                        Text("プロフィール更新")
                    }
                }
            }
        }
    }
}

@Composable
fun UserProfileScreen(profileUserId: Int, snackbarHostState: SnackbarHostState) {
    var displayName by remember { mutableStateOf("") }
    var description by remember { mutableStateOf("") }
    var profileImageBase64 by remember { mutableStateOf("") }
    var isLoading by remember { mutableStateOf(true) }
    val coroutineScope = rememberCoroutineScope()

    LaunchedEffect(profileUserId) {
        try {
            val response = RetrofitClient.apiService.getProfile(profileUserId)
            if (response.success) {
                displayName = response.displayName ?: ""
                description = response.description ?: ""
                profileImageBase64 = response.profileImageBase64 ?: ""
            }
        } catch (e: Exception) {
            Log.e(TAG, "他ユーザーのプロフィール取得エラー", e)
        } finally {
            isLoading = false
        }
    }

    if (isLoading) {
        Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) { CircularProgressIndicator() }
    } else {
        Box(modifier = Modifier
            .fillMaxSize()
            .padding(16.dp)
            .background(Color.White)) {
            Column(modifier = Modifier.padding(24.dp)) {
                ProfileImagePreview(profileImageBase64)
                Spacer(modifier = Modifier.height(16.dp))
                Text("表示名: $displayName", style = MaterialTheme.typography.headlineSmall)
                Spacer(modifier = Modifier.height(8.dp))
                Text("自己紹介:", style = MaterialTheme.typography.headlineSmall)
                Text(description, style = MaterialTheme.typography.bodyLarge)
            }
        }
    }
}

@Composable
fun TaskEditScreen(taskId: Int, navController: NavHostController, snackbarHostState: SnackbarHostState) {
    var title by remember { mutableStateOf("") }
    var description by remember { mutableStateOf("") }
    var isLoading by remember { mutableStateOf(true) }
    var isSaving by remember { mutableStateOf(false) }
    var lastSavedTime by remember { mutableStateOf<Date?>(null) }
    var isDirty by remember { mutableStateOf(false) }
    val coroutineScope = rememberCoroutineScope()

    LaunchedEffect(taskId) {
        try {
            val tasksResponse = RetrofitClient.apiService.getTasks()
            if (tasksResponse.success) {
                tasksResponse.tasks.find { it.id == taskId }?.let { task ->
                    title = task.title
                    description = task.description
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "タスク取得エラー", e)
        } finally {
            isLoading = false
        }
    }

    LaunchedEffect(isDirty) {
        if (isDirty) {
            delay(10_000)
            if (isDirty) {
                isSaving = true
                try {
                    if (title.isBlank() || description.isBlank()) {
                        snackbarHostState.showSnackbar("タイトルと説明は必須です。")
                    } else {
                        val response = RetrofitClient.apiService.editTask(TaskEditRequest(taskId, title, description))
                        if (response.success) {
                            lastSavedTime = Date()
                            snackbarHostState.showSnackbar("自動保存しました")
                            isDirty = false
                        } else {
                            snackbarHostState.showSnackbar("自動保存に失敗しました")
                        }
                    }
                } catch (e: Exception) {
                    Log.e(TAG, "自動保存エラー", e)
                    snackbarHostState.showSnackbar("サーバーエラー：自動保存に失敗しました")
                } finally {
                    isSaving = false
                }
            }
        }
    }

    if (isLoading) {
        Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) { CircularProgressIndicator() }
    } else {
        Scaffold(snackbarHost = { SnackbarHost(hostState = snackbarHostState) }) { padding ->
            Card(modifier = Modifier
                .fillMaxSize()
                .padding(24.dp)
                .padding(padding),
                shape = RoundedCornerShape(16.dp),
                elevation = CardDefaults.cardElevation(8.dp)
            ) {
                Column(modifier = Modifier.padding(24.dp)) {
                    Text("タスク編集", style = MaterialTheme.typography.headlineMedium)
                    Spacer(modifier = Modifier.height(16.dp))
                    OutlinedTextField(
                        value = title,
                        onValueChange = {
                            title = it
                            isDirty = true
                        },
                        label = { Text("タスクタイトル（必須、最大50文字）") },
                        modifier = Modifier.fillMaxWidth(),
                        isError = title.isBlank() || title.length > 50
                    )
                    if (title.isBlank()) {
                        Text("タイトルは必須です", style = MaterialTheme.typography.labelSmall, color = Color.Red)
                    } else if (title.length > 50) {
                        Text("タイトルは50文字以内", style = MaterialTheme.typography.labelSmall, color = Color.Red)
                    }
                    Spacer(modifier = Modifier.height(8.dp))
                    OutlinedTextField(
                        value = description,
                        onValueChange = {
                            description = it
                            isDirty = true
                        },
                        label = { Text("タスク説明（必須、最大200文字）") },
                        modifier = Modifier.fillMaxWidth(),
                        isError = description.isBlank() || description.length > 200
                    )
                    if (description.isBlank()) {
                        Text("説明は必須です", style = MaterialTheme.typography.labelSmall, color = Color.Red)
                    } else if (description.length > 200) {
                        Text("説明は200文字以内", style = MaterialTheme.typography.labelSmall, color = Color.Red)
                    }
                    Spacer(modifier = Modifier.height(16.dp))
                    ElevatedButton(
                        onClick = {
                            coroutineScope.launch {
                                isSaving = true
                                try {
                                    if (title.isBlank() || description.isBlank()) {
                                        snackbarHostState.showSnackbar("タイトルと説明は必須です。")
                                    } else {
                                        val response = RetrofitClient.apiService.editTask(TaskEditRequest(taskId, title, description))
                                        if (response.success) {
                                            lastSavedTime = Date()
                                            snackbarHostState.showSnackbar("保存しました")
                                            isDirty = false
                                            navController.popBackStack()
                                        } else {
                                            snackbarHostState.showSnackbar("保存に失敗しました")
                                        }
                                    }
                                } catch (e: Exception) {
                                    Log.e(TAG, "保存エラー", e)
                                    snackbarHostState.showSnackbar("サーバーエラーが発生しました")
                                } finally {
                                    isSaving = false
                                }
                            }
                        },
                        modifier = Modifier.fillMaxWidth(),
                        enabled = !isSaving
                    ) {
                        if (isSaving) {
                            CircularProgressIndicator(modifier = Modifier.size(20.dp), strokeWidth = 2.dp)
                        } else {
                            Text("保存")
                        }
                    }
                    Spacer(modifier = Modifier.height(8.dp))
                    lastSavedTime?.let {
                        Text("最終保存: ${SimpleDateFormat("HH:mm:ss", Locale.getDefault()).format(it)}", style = MaterialTheme.typography.labelSmall)
                    }
                }
            }
        }
    }
}

@Composable
fun ScheduleEditScreen(scheduleId: Int, navController: NavHostController, snackbarHostState: SnackbarHostState) {
    var scheduledDate by remember { mutableStateOf("2025-01-01 09:00:00") }
    var scheduleDesc by remember { mutableStateOf("既存のスケジュール内容") }
    var isLoading by remember { mutableStateOf(true) }
    val coroutineScope = rememberCoroutineScope()
    val context = LocalContext.current

    LaunchedEffect(scheduleId) {
        // APIから既存スケジュールを取得する想定
        isLoading = false
    }

    if (isLoading) {
        Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) { CircularProgressIndicator() }
    } else {
        Card(modifier = Modifier
            .fillMaxSize()
            .padding(24.dp),
            shape = RoundedCornerShape(16.dp),
            elevation = CardDefaults.cardElevation(8.dp)
        ) {
            Column(modifier = Modifier.padding(24.dp)) {
                Text("スケジュール編集", style = MaterialTheme.typography.headlineMedium)
                Spacer(modifier = Modifier.height(16.dp))
                ElevatedButton(onClick = {
                    val calendar = Calendar.getInstance()
                    DatePickerDialog(context, { _, year, month, dayOfMonth ->
                        val cal = Calendar.getInstance().apply { set(year, month, dayOfMonth) }
                        val dateStr = SimpleDateFormat("yyyy-MM-dd", Locale.getDefault()).format(cal.time)
                        val timePart = scheduledDate.split(" ").getOrElse(1) { "09:00:00" }
                        scheduledDate = "$dateStr $timePart"
                    }, calendar.get(Calendar.YEAR), calendar.get(Calendar.MONTH), calendar.get(Calendar.DAY_OF_MONTH)).show()
                }) {
                    Text("日付を変更（現在: ${scheduledDate.split(" ")[0]})")
                }
                Spacer(modifier = Modifier.height(8.dp))
                OutlinedTextField(
                    value = scheduleDesc,
                    onValueChange = { scheduleDesc = it },
                    label = { Text("スケジュール内容（必須、最大200文字）") },
                    modifier = Modifier.fillMaxWidth(),
                    isError = scheduleDesc.isBlank() || scheduleDesc.length > 200
                )
                if (scheduleDesc.isBlank()) {
                    Text("スケジュール内容は必須です", style = MaterialTheme.typography.labelSmall, color = Color.Red)
                } else if (scheduleDesc.length > 200) {
                    Text("スケジュール内容は200文字以内", style = MaterialTheme.typography.labelSmall, color = Color.Red)
                }
                Spacer(modifier = Modifier.height(16.dp))
                ElevatedButton(onClick = {
                    coroutineScope.launch {
                        try {
                            val response = RetrofitClient.apiService.editSchedule(
                                ScheduleEditRequest(scheduleId, scheduledDate, scheduleDesc)
                            )
                            if (response.success) {
                                snackbarHostState.showSnackbar("スケジュール編集成功")
                                navController.popBackStack()
                            } else {
                                snackbarHostState.showSnackbar("スケジュール編集失敗")
                            }
                        } catch (e: Exception) {
                            Log.e(TAG, "スケジュール編集エラー", e)
                            snackbarHostState.showSnackbar("サーバーエラー")
                        }
                    }
                }, modifier = Modifier.fillMaxWidth()) {
                    Text("保存")
                }
            }
        }
    }
}

// ─── 登録済みタスク（スケジュール管理画面）のUI刷新 ─────────────────────────

@Composable
fun TaskScheduleManagementScreen(taskId: Int, navController: NavHostController, currentUserId: Int, snackbarHostState: SnackbarHostState) {
    if (taskId == 0) {
        Column(modifier = Modifier.fillMaxSize().padding(16.dp),
            verticalArrangement = Arrangement.Center,
            horizontalAlignment = Alignment.CenterHorizontally) {
            Text("タスクが選択されていません。")
            Spacer(modifier = Modifier.height(8.dp))
            ElevatedButton(onClick = { navController.navigate("taskList") }) { Text("タスクリストへ") }
        }
        return
    }
    var taskData by remember { mutableStateOf<TaskData?>(null) }
    LaunchedEffect(taskId) {
        try {
            val tasksResponse = RetrofitClient.apiService.getTasks()
            if (tasksResponse.success) {
                taskData = tasksResponse.tasks.find { it.id == taskId }
            }
        } catch (e: Exception) {
            Log.e(TAG, "タスク取得エラー", e)
        }
    }
    val scheduleViewModel: TaskScheduleViewModel = viewModel(factory = object : ViewModelProvider.Factory {
        @Suppress("UNCHECKED_CAST")
        override fun <T : ViewModel> create(modelClass: Class<T>): T =
            TaskScheduleViewModel(taskId) as T
    })
    var selectedRange by remember { mutableStateOf<DateRange?>(null) }
    var taskDescription by remember { mutableStateOf("") }
    var allDay by remember { mutableStateOf(true) }
    var startTime by remember { mutableStateOf("00:00") }
    var endTime by remember { mutableStateOf("23:59") }
    val context = LocalContext.current
    var showVoteDetailsDialog by remember { mutableStateOf(false) }
    var voteDetails by remember { mutableStateOf(listOf<VoteDetail>()) }
    Column(modifier = Modifier
        .fillMaxSize()
        .verticalScroll(rememberScrollState())
        .padding(16.dp)) {
        taskData?.let { task ->
            Row(verticalAlignment = Alignment.CenterVertically) {
                if (!task.creatorProfileImage.isNullOrEmpty()) {
                    ProfileImage(task.creatorProfileImage, modifier = Modifier.size(40.dp))
                } else {
                    Icon(Icons.Filled.Person, contentDescription = "Default Profile", modifier = Modifier.size(40.dp))
                }
                Spacer(modifier = Modifier.width(8.dp))
                Text(task.creatorDisplayName, style = MaterialTheme.typography.bodyLarge)
            }
            Spacer(modifier = Modifier.height(16.dp))
        }
        if (taskData != null && currentUserId == taskData!!.creatorId && taskData!!.status != "完了済み") {
            ElevatedButton(onClick = {
                CoroutineScope(Dispatchers.IO).launch {
                    try {
                        val response = RetrofitClient.apiService.completeTask(TaskCompleteRequest(taskId))
                        if (response.success) {
                            taskData = taskData?.copy(status = "完了済み")
                        }
                    } catch (e: Exception) {
                        Log.e(TAG, "タスク完了更新エラー", e)
                    }
                }
            }, modifier = Modifier.fillMaxWidth()) {
                Text("タスク完了")
            }
            Spacer(modifier = Modifier.height(16.dp))
        }
        Text("タスクのスケジュール管理", style = MaterialTheme.typography.headlineMedium)
        Spacer(modifier = Modifier.height(16.dp))
        ImprovedCalendar(selectedRange = selectedRange, onRangeSelected = { selectedRange = it })
        Spacer(modifier = Modifier.height(16.dp))
        if (selectedRange != null) {
            Text("選択範囲: ${SimpleDateFormat("yyyy/MM/dd", Locale.getDefault()).format(selectedRange!!.start)} ～ ${SimpleDateFormat("yyyy/MM/dd", Locale.getDefault()).format(selectedRange!!.end)}")
        } else {
            Text("日付範囲を選択してください")
        }
        Spacer(modifier = Modifier.height(8.dp))
        Row(verticalAlignment = Alignment.CenterVertically) {
            Checkbox(checked = allDay, onCheckedChange = { allDay = it })
            Text("終日")
        }
        if (!allDay) {
            TimePickerButton(label = "開始時刻", time = startTime) { startTime = it }
            Spacer(modifier = Modifier.height(4.dp))
            TimePickerButton(label = "終了時刻", time = endTime) { endTime = it }
        }
        Spacer(modifier = Modifier.height(8.dp))
        OutlinedTextField(
            value = taskDescription,
            onValueChange = { taskDescription = it },
            label = { Text("タスク説明（必須）") },
            modifier = Modifier.fillMaxWidth(),
            isError = taskDescription.isBlank()
        )
        Spacer(modifier = Modifier.height(8.dp))
        ElevatedButton(
            onClick = {
                if (selectedRange != null && taskDescription.isNotBlank()) {
                    val startDateTime = if (allDay) combineDateTime(selectedRange!!.start, "00:00") else combineDateTime(selectedRange!!.start, startTime)
                    val endDateTime = if (allDay) combineDateTime(selectedRange!!.end, "23:59") else combineDateTime(selectedRange!!.end, endTime)
                    scheduleViewModel.addSchedule(startDateTime, endDateTime, taskDescription, currentUserId)
                    selectedRange = null
                    taskDescription = ""
                }
            },
            enabled = selectedRange != null && taskDescription.isNotBlank(),
            modifier = Modifier.fillMaxWidth()
        ) {
            Text("送信")
        }
        Spacer(modifier = Modifier.height(16.dp))
        Text("登録済みのタスク", style = MaterialTheme.typography.headlineSmall)
        Spacer(modifier = Modifier.height(8.dp))
        if (scheduleViewModel.schedules.isEmpty()) {
            Text("まだタスクは追加されていません")
        } else {
            scheduleViewModel.schedules.forEach { schedule ->
                // 新UI：プロフィール画像・ユーザー名、内容、期間、予定日時、ボタン群
                Card(modifier = Modifier
                    .fillMaxWidth()
                    .padding(vertical = 4.dp),
                    shape = RoundedCornerShape(8.dp),
                    elevation = CardDefaults.cardElevation(2.dp)
                ) {
                    Column(modifier = Modifier.padding(8.dp)) {
                        // プロフィール画像とユーザー名
                        Row(verticalAlignment = Alignment.CenterVertically) {
                            if (!schedule.registeredUserProfileImage.isNullOrEmpty()) {
                                ProfileImage(schedule.registeredUserProfileImage, modifier = Modifier.size(40.dp))
                            } else {
                                Icon(Icons.Filled.Person, contentDescription = "Profile", modifier = Modifier.size(40.dp))
                            }
                            Spacer(modifier = Modifier.width(8.dp))
                            Text(schedule.registeredUserName ?: "不明なユーザー", style = MaterialTheme.typography.bodyLarge)
                        }
                        Divider(modifier = Modifier.padding(vertical = 4.dp))
                        // 内容
                        Text("内容:", style = MaterialTheme.typography.labelMedium)
                        // scheduleDescriptionは "期間: ～ | 内容" 形式を想定
                        val parts = schedule.scheduleDescription.split("|")
                        val contentText = if (parts.size > 1) parts[1].trim() else schedule.scheduleDescription
                        Text(contentText, style = MaterialTheme.typography.bodyMedium)
                        Divider(modifier = Modifier.padding(vertical = 4.dp))
                        // 期間
                        Text("期間:", style = MaterialTheme.typography.labelMedium)
                        val periodText = if (parts.isNotEmpty()) parts[0].trim() else ""
                        Text(periodText, style = MaterialTheme.typography.bodyMedium)
                        Divider(modifier = Modifier.padding(vertical = 4.dp))
                        // 予定日時
                        Text("予定日時:", style = MaterialTheme.typography.labelMedium)
                        val dateTimeText = try {
                            val parser = SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.getDefault())
                            val formatter = SimpleDateFormat("MM/dd HH:mm", Locale.getDefault())
                            formatter.format(parser.parse(schedule.scheduledDate)!!)
                        } catch (e: Exception) {
                            schedule.scheduledDate
                        }
                        Text(dateTimeText, style = MaterialTheme.typography.bodyMedium)
                        Divider(modifier = Modifier.padding(vertical = 4.dp))
                        // ボタン群：投票、投票数、詳細、完了（タスク作成者のみ表示）
                        Row(modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceEvenly, verticalAlignment = Alignment.CenterVertically) {
                            var voteCount by remember { mutableStateOf(0) }
                            LaunchedEffect(schedule.id) {
                                try {
                                    val voteResponse = RetrofitClient.apiService.getVotes(schedule.id)
                                    if (voteResponse.success && voteResponse.voteCount != null) {
                                        voteCount = voteResponse.voteCount
                                    }
                                } catch (e: Exception) {
                                    Log.e(TAG, "Vote count取得エラー", e)
                                }
                            }
                            ElevatedButton(onClick = {
                                CoroutineScope(Dispatchers.IO).launch {
                                    try {
                                        val response = RetrofitClient.apiService.voteSchedule(VoteRequest(schedule.id, currentUserId))
                                        if (response.success) {
                                            voteCount++ // 楽観的更新
                                            scheduleViewModel.fetchSchedules()
                                        }
                                    } catch (e: Exception) {
                                        Log.e(TAG, "Error voting", e)
                                    }
                                }
                            }) {
                                Text("投票")
                            }
                            Text("投票数: $voteCount", style = MaterialTheme.typography.bodySmall)
                            val coroutineScope = rememberCoroutineScope()
                            ElevatedButton(onClick = {
                                coroutineScope.launch {
                                    try {
                                        val detailsResponse = RetrofitClient.apiService.getVoteDetails(schedule.id)
                                        if (detailsResponse.success) {
                                            voteDetails = detailsResponse.details
                                            showVoteDetailsDialog = true
                                        }
                                    } catch (e: Exception) {
                                        Log.e(TAG, "Vote details取得エラー", e)
                                    }
                                }
                            }) {
                                Text("詳細")
                            }
                            if (taskData != null && currentUserId == taskData!!.creatorId) {
                                ElevatedButton(onClick = { scheduleViewModel.finalizeSchedule(taskId, schedule.id) }) {
                                    Text("完了")
                                }
                            }
                        }
                    }
                }
            }
        }
        Spacer(modifier = Modifier.height(16.dp))
        ElevatedButton(onClick = { navController.navigate("taskParticipants/${taskId}") }, modifier = Modifier.fillMaxWidth()) {
            Text("参加者一覧")
        }
    }
    if (showVoteDetailsDialog) {
        AlertDialog(
            onDismissRequest = { showVoteDetailsDialog = false },
            title = { Text("投票詳細") },
            text = {
                LazyColumn {
                    items(voteDetails) { detail ->
                        Row(verticalAlignment = Alignment.CenterVertically) {
                            if (detail.profileImageBase64 != null) {
                                ProfileImage(detail.profileImageBase64, modifier = Modifier.size(40.dp))
                            } else {
                                Icon(Icons.Filled.Person, contentDescription = "Profile", modifier = Modifier.size(40.dp))
                            }
                            Spacer(modifier = Modifier.width(8.dp))
                            Text(detail.displayName)
                        }
                    }
                }
            },
            confirmButton = {
                ElevatedButton(onClick = { showVoteDetailsDialog = false }) { Text("閉じる") }
            }
        )
    }
}

class TaskScheduleViewModel(private val taskId: Int) : ViewModel() {
    var schedules by mutableStateOf<List<ScheduleData>>(emptyList())
        private set

    init { fetchSchedules() }

    fun fetchSchedules() {
        viewModelScope.launch {
            try {
                val response = RetrofitClient.apiService.getSchedules(taskId)
                if (response.success) {
                    schedules = response.schedules
                } else {
                    Log.e(TAG, "Failed to fetch schedules")
                }
            } catch (e: Exception) {
                Log.e(TAG, "Error fetching schedules", e)
            }
        }
    }

    fun addSchedule(startDate: Date, endDate: Date, description: String, userId: Int) {
        viewModelScope.launch {
            try {
                val scheduledDateStr = SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.getDefault()).format(startDate)
                // フォーマット例："期間: yyyy/MM/dd ～ yyyy/MM/dd | 内容"
                val formattedSchedule = "期間: ${formatDate(startDate)} ～ ${formatDate(endDate)} | $description"
                val response = RetrofitClient.apiService.addSchedule(ScheduleAddRequest(taskId, scheduledDateStr, formattedSchedule, userId))
                if (response.success) {
                    fetchSchedules()
                } else {
                    Log.e(TAG, "Failed to add schedule")
                }
            } catch (e: Exception) {
                Log.e(TAG, "Error adding schedule", e)
            }
        }
    }

    fun finalizeSchedule(taskId: Int, scheduleId: Int) {
        viewModelScope.launch {
            try {
                val response = RetrofitClient.apiService.finalizeSchedule(FinalizeRequest(taskId, scheduleId))
                if (response.success) {
                    fetchSchedules()
                } else {
                    Log.e(TAG, "Finalize failed")
                }
            } catch (e: Exception) {
                Log.e(TAG, "Error finalizing schedule", e)
            }
        }
    }
}



@Composable
fun TaskParticipantsScreen(
    taskId: Int,
    navController: NavHostController,
    snackbarHostState: SnackbarHostState
) {
    var participants by remember { mutableStateOf(listOf<Participant>()) }
    var isLoading by remember { mutableStateOf(true) }
    val coroutineScope = rememberCoroutineScope()

    LaunchedEffect(taskId) {
        try {
            val response = RetrofitClient.apiService.getTaskParticipants(taskId)
            if (response.success) {
                participants = response.participants
            }
        } catch (e: Exception) {
            Log.e(TAG, "参加者取得エラー", e)
        } finally {
            isLoading = false
        }
    }

    Scaffold(
        topBar = {
            CenterAlignedTopAppBar(
                title = { Text("参加者一覧") },
                navigationIcon = {
                    IconButton(onClick = { navController.popBackStack() }) {
                        Icon(Icons.Filled.ArrowBack, contentDescription = "Back")
                    }
                },
                colors = TopAppBarDefaults.centerAlignedTopAppBarColors(containerColor = LightColorScheme.primary)
            )
        },
        snackbarHost = { SnackbarHost(hostState = snackbarHostState) }
    ) { padding ->
        if (isLoading) {
            Box(modifier = Modifier.fillMaxSize().padding(padding), contentAlignment = Alignment.Center) {
                CircularProgressIndicator()
            }
        } else {
            LazyColumn(modifier = Modifier.fillMaxSize().padding(padding)) {
                items(participants) { user ->
                    Row(
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(8.dp),
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        if (user.profileImageBase64 != null) {
                            ProfileImage(user.profileImageBase64, modifier = Modifier.size(40.dp))
                        } else {
                            Icon(
                                imageVector = Icons.Filled.Person,
                                contentDescription = "Profile",
                                modifier = Modifier.size(40.dp)
                            )
                        }
                        Spacer(modifier = Modifier.width(8.dp))
                        Text(user.displayName)
                    }
                }
            }
        }
    }
}




class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        val sessionManager = SessionManager(applicationContext)
        setContent {
            LightTaskunTheme {
                val navController = rememberNavController()
                val snackbarHostState = remember { SnackbarHostState() }
                val startDestination = if (sessionManager.fetchAuthToken() != null) "main" else "register"
                NavHost(navController = navController, startDestination = startDestination) {
                    composable("register") { RegistrationScreen(navController, sessionManager, snackbarHostState) }
                    composable("login") { LoginScreen(navController, sessionManager, snackbarHostState) }
                    composable("main") {
                        MainScreen(userId = sessionManager.fetchUserId(), sessionManager = sessionManager, outerNavController = navController, snackbarHostState = snackbarHostState)
                    }
                    composable("taskEdit/{taskId}") { backStackEntry ->
                        val taskId = backStackEntry.arguments?.getString("taskId")?.toInt() ?: 0
                        TaskEditScreen(taskId, navController, snackbarHostState)
                    }
                    composable("scheduleEdit/{scheduleId}") { backStackEntry ->
                        val scheduleId = backStackEntry.arguments?.getString("scheduleId")?.toInt() ?: 0
                        ScheduleEditScreen(scheduleId, navController, snackbarHostState)
                    }
                    composable("taskParticipants/{taskId}") { backStackEntry ->
                        val taskId = backStackEntry.arguments?.getString("taskId")?.toInt() ?: 0
                        TaskParticipantsScreen(taskId, navController, snackbarHostState)
                    }
                    composable("taskScheduleManagement/{taskId}") { backStackEntry ->
                        val taskId = backStackEntry.arguments?.getString("taskId")?.toInt() ?: 0
                        TaskScheduleManagementScreen(taskId, navController, sessionManager.fetchUserId(), snackbarHostState)
                    }
                    composable("taskRegistration") { TaskRegistrationScreen(sessionManager.fetchUserId(), snackbarHostState) }
                    composable("profileRegistration") { ProfileRegistrationScreen(sessionManager.fetchUserId(), snackbarHostState) }
                    composable("profileView/{userId}") { backStackEntry ->
                        val profileUserId = backStackEntry.arguments?.getString("userId")?.toInt() ?: 0
                        UserProfileScreen(profileUserId, snackbarHostState)
                    }
                    composable("instruction") { InstructionScreen(navController) }
                }
            }
        }
    }
}

const express = require('express');
const mysql = require('mysql2');
const crypto = require('crypto');

const app = express();
// 画像や大きなペイロードも受け取れるように（10MBまで）
app.use(express.json({ limit: '10mb' }));

// MySQL 接続設定（環境に合わせて変更）
const db = mysql.createConnection({
  host: 'localhost',
  user: 'root',
  password: 'root12345',
  database: 'taskun_data'
});

db.connect(err => {
  if (err) {
    console.error('MySQL 接続エラー:', err);
    process.exit(1);
  }
  console.log('MySQL に接続しました。');
});

// 簡易入力検証関数
function validateString(input, fieldName, minLen = 1, maxLen = 100) {
  if (!input || typeof input !== 'string' || input.trim().length < minLen) {
    return `${fieldName}は必須です。`;
  }
  if (input.length > maxLen) {
    return `${fieldName}は${maxLen}文字以内で入力してください。`;
  }
  if (/[*<>]/.test(input)) {
    return `${fieldName}に不正な文字が含まれています。`;
  }
  return null;
}

// ----------------------
// 認証エンドポイント
app.post('/register', (req, res) => {
  const { username, password, displayName } = req.body;
  let error = validateString(username, "ユーザーネーム", 1, 50) ||
              validateString(password, "パスワード", 6, 255) ||
              validateString(displayName, "表示名", 1, 100);
  if (error) {
    return res.status(400).json({ success: false, message: error });
  }
  const checkQuery = 'SELECT * FROM users WHERE username = ?';
  db.query(checkQuery, [username], (err, results) => {
    if (err) {
      console.error(err);
      return res.status(500).json({ success: false, message: 'データベースエラー' });
    }
    if (results.length > 0) {
      return res.status(400).json({ success: false, message: '既に存在するユーザ名です。' });
    }
    const insertQuery = 'INSERT INTO users (username, password, display_name, status) VALUES (?, ?, ?, "進行中")';
    db.query(insertQuery, [username, password, displayName], (err, result) => {
      if (err) {
        console.error(err);
        return res.status(500).json({ success: false, message: 'データベースエラー' });
      }
      const token = crypto.randomBytes(16).toString('hex');
      res.json({ success: true, token, userId: result.insertId });
    });
  });
});

app.post('/login', (req, res) => {
  const { username, password } = req.body;
  let error = validateString(username, "ユーザーネーム", 1, 50) || validateString(password, "パスワード", 6, 255);
  if (error) {
    return res.status(400).json({ success: false, message: error });
  }
  const query = 'SELECT * FROM users WHERE username = ? AND password = ?';
  db.query(query, [username, password], (err, results) => {
    if (err) {
      console.error(err);
      return res.status(500).json({ success: false, message: 'データベースエラー' });
    }
    if (results.length === 0) {
      return res.status(400).json({ success: false, message: 'ユーザ名またはパスワードが正しくありません。' });
    }
    const token = crypto.randomBytes(16).toString('hex');
    res.json({ success: true, token, userId: results[0].id });
  });
});

// ----------------------
// タスク関連エンドポイント
app.get('/tasks', (req, res) => {
  const query = `
    SELECT tasks.id, tasks.title, tasks.description, tasks.created_at, tasks.status, 
           users.display_name, users.profile_image, users.id as creatorId
    FROM tasks 
    JOIN users ON tasks.creator_id = users.id
    ORDER BY tasks.created_at DESC
  `;
  db.query(query, (err, results) => {
    if (err) {
      console.error(err);
      return res.status(500).json({ success: false, message: 'データベースエラー' });
    }
    const tasks = results.map(task => ({
      id: task.id,
      title: task.title,
      description: task.description,
      created_at: task.created_at,
      status: task.status,
      creatorDisplayName: task.display_name,
      creatorProfileImage: task.profile_image ? Buffer.from(task.profile_image).toString('base64') : null,
      creatorId: task.creatorId
    }));
    res.json({ success: true, tasks });
  });
});

app.post('/tasks', (req, res) => {
  const { userId, title, description } = req.body;
  let error = validateString(title, "タスクタイトル", 1, 50) || validateString(description, "タスク説明", 1, 200);
  if (!userId || error) {
    return res.status(400).json({ success: false, message: error || 'userIdは必須です。' });
  }
  const query = 'INSERT INTO tasks (title, description, creator_id, status) VALUES (?, ?, ?, "進行中")';
  db.query(query, [title, description, userId], (err, result) => {
    if (err) {
      console.error(err);
      return res.status(500).json({ success: false, message: 'データベースエラー' });
    }
    res.json({ success: true, taskId: result.insertId });
  });
});

app.post('/tasks/edit', (req, res) => {
  const { taskId, title, description } = req.body;
  let error = validateString(title, "タスクタイトル", 1, 50) || validateString(description, "タスク説明", 1, 200);
  if (!taskId || error) {
    return res.status(400).json({ success: false, message: error || '全ての項目が必要です。' });
  }
  const query = 'UPDATE tasks SET title = ?, description = ? WHERE id = ?';
  db.query(query, [title, description, taskId], (err, result) => {
    if (err) {
      console.error(err);
      return res.status(500).json({ success: false, message: 'データベースエラー' });
    }
    res.json({ success: true });
  });
});

app.post('/tasks/complete', (req, res) => {
  const { taskId } = req.body;
  if (!taskId) {
    return res.status(400).json({ success: false, message: 'taskId は必須です。' });
  }
  const query = 'UPDATE tasks SET status = "完了済み" WHERE id = ?';
  db.query(query, [taskId], (err, result) => {
    if (err) {
      console.error(err);
      return res.status(500).json({ success: false });
    }
    res.json({ success: true });
  });
});

app.post('/tasks/join', (req, res) => {
  const { userId, taskId } = req.body;
  if (!userId || !taskId) {
    return res.status(400).json({ success: false, message: 'userId と taskId は必須です。' });
  }
  const checkQuery = 'SELECT * FROM task_participants WHERE task_id = ? AND user_id = ?';
  db.query(checkQuery, [taskId, userId], (err, results) => {
    if (err) {
      console.error(err);
      return res.status(500).json({ success: false, message: 'データベースエラー' });
    }
    if (results.length > 0) {
      return res.json({ success: true, message: '既に参加済みです。' });
    }
    const query = 'INSERT INTO task_participants (task_id, user_id) VALUES (?, ?)';
    db.query(query, [taskId, userId], (err, result) => {
      if (err) {
        console.error(err);
        return res.status(500).json({ success: false, message: 'データベースエラー' });
      }
      res.json({ success: true });
    });
  });
});

// ----------------------
// プロフィール取得／更新
app.get('/profile/:userId', (req, res) => {
  const userId = req.params.userId;
  const query = 'SELECT display_name, description, profile_image FROM users WHERE id = ?';
  db.query(query, [userId], (err, results) => {
    if (err) {
      console.error(err);
      return res.status(500).json({ success: false, message: 'データベースエラー' });
    }
    if (results.length === 0) {
      return res.status(404).json({ success: false, message: 'ユーザーが見つかりません' });
    }
    const user = results[0];
    res.json({
      success: true,
      displayName: user.display_name,
      description: user.description,
      profileImageBase64: user.profile_image ? Buffer.from(user.profile_image).toString('base64') : null
    });
  });
});

app.post('/profile', (req, res) => {
  const { userId, displayName, description, profileImageBase64 } = req.body;
  let error = validateString(displayName, "表示名", 1, 100);
  if (!userId || error) {
    return res.status(400).json({ success: false, message: error || 'userId と displayName は必須です。' });
  }
  let imageBuffer = null;
  if (profileImageBase64) {
    try {
      imageBuffer = Buffer.from(profileImageBase64, 'base64');
    } catch (e) {
      console.error('Error converting profileImageBase64', e);
      return res.status(400).json({ success: false, message: 'Invalid profileImageBase64 format' });
    }
  }
  const query = 'UPDATE users SET display_name = ?, description = ?, profile_image = ? WHERE id = ?';
  db.query(query, [displayName, description || null, imageBuffer, userId], (err, result) => {
    if (err) {
      console.error(err);
      return res.status(500).json({ success: false, message: 'データベースエラー' });
    }
    res.json({ success: true });
  });
});

// ----------------------
// タスクスケジュール取得／追加／編集／削除
app.get('/tasks/schedule/:taskId', (req, res) => {
  const { taskId } = req.params;
  const query = `
    SELECT ts.id, ts.scheduled_date, ts.schedule_description, ts.finalized,
           u.display_name AS registeredUserName,
           u.profile_image AS registeredUserProfileImage
    FROM task_schedules ts
    JOIN users u ON ts.registered_user_id = u.id
    WHERE ts.task_id = ?
    ORDER BY ts.scheduled_date ASC
  `;
  db.query(query, [taskId], (err, results) => {
    if (err) {
      console.error(err);
      return res.status(500).json({ success: false, message: 'データベースエラー' });
    }
    const schedules = results.map(item => ({
      id: item.id,
      scheduled_date: item.scheduled_date,
      schedule_description: item.schedule_description,
      finalized: item.finalized === 1,
      registeredUserName: item.registeredUserName,
      registeredUserProfileImage: item.registeredUserProfileImage ? Buffer.from(item.registeredUserProfileImage).toString('base64') : null
    }));
    res.json({ success: true, schedules });
  });
});

app.post('/tasks/schedule', (req, res) => {
  const { taskId, scheduledDate, schedule, userId } = req.body;
  let error = validateString(scheduledDate, "日時", 1, 50) || validateString(schedule, "スケジュール内容", 1, 200);
  if (!taskId || !userId || error) {
    return res.status(400).json({ success: false, message: error || 'taskId, scheduledDate, schedule, userId は必須です。' });
  }
  const insertQuery = `
    INSERT INTO task_schedules (task_id, scheduled_date, schedule_description, registered_user_id, finalized)
    VALUES (?, ?, ?, ?, false)
  `;
  db.query(insertQuery, [taskId, scheduledDate, schedule, userId], (err, result) => {
    if (err) {
      console.error(err);
      return res.status(500).json({ success: false, message: 'データベースエラー' });
    }
    res.json({ success: true, scheduleId: result.insertId });
  });
});

app.post('/tasks/schedule/edit', (req, res) => {
  const { scheduleId, scheduledDate, schedule } = req.body;
  let error = validateString(scheduledDate, "日時", 1, 50) || validateString(schedule, "スケジュール内容", 1, 200);
  if (!scheduleId || error) {
    return res.status(400).json({ success: false, message: error || '全ての項目が必要です。' });
  }
  const query = 'UPDATE task_schedules SET scheduled_date = ?, schedule_description = ? WHERE id = ?';
  db.query(query, [scheduledDate, schedule, scheduleId], (err, result) => {
    if (err) {
      console.error(err);
      return res.status(500).json({ success: false, message: 'データベースエラー' });
    }
    res.json({ success: true });
  });
});

app.post('/tasks/schedule/delete', (req, res) => {
  const { scheduleId } = req.body;
  if (!scheduleId) {
    return res.status(400).json({ success: false, message: 'scheduleId は必須です。' });
  }
  const query = 'DELETE FROM task_schedules WHERE id = ?';
  db.query(query, [scheduleId], (err, result) => {
    if (err) {
      console.error(err);
      return res.status(500).json({ success: false, message: 'データベースエラー' });
    }
    res.json({ success: true });
  });
});

// ----------------------
// スケジュール投票／詳細取得
app.get('/tasks/schedule/votes/:scheduleId', (req, res) => {
  const { scheduleId } = req.params;
  const query = 'SELECT COUNT(*) AS voteCount FROM schedule_votes WHERE schedule_id = ?';
  db.query(query, [scheduleId], (err, results) => {
    if (err) {
      console.error(err);
      return res.status(500).json({ success: false });
    }
    res.json({ success: true, voteCount: results[0].voteCount });
  });
});

app.post('/tasks/schedule/vote', (req, res) => {
  const { scheduleId, userId } = req.body;
  if (!scheduleId || !userId) {
    return res.status(400).json({ success: false, message: 'scheduleId と userId は必須です。' });
  }
  const checkQuery = 'SELECT * FROM schedule_votes WHERE schedule_id = ? AND user_id = ?';
  db.query(checkQuery, [scheduleId, userId], (err, results) => {
    if (err) {
      console.error(err);
      return res.status(500).json({ success: false });
    }
    if (results.length > 0) {
      return res.status(400).json({ success: false, message: '既に投票済みです。' });
    }
    const insertQuery = 'INSERT INTO schedule_votes (schedule_id, user_id, vote) VALUES (?, ?, 1)';
    db.query(insertQuery, [scheduleId, userId], (err, result) => {
      if (err) {
        console.error(err);
        return res.status(500).json({ success: false });
      }
      const countQuery = 'SELECT COUNT(*) AS voteCount FROM schedule_votes WHERE schedule_id = ?';
      db.query(countQuery, [scheduleId], (err, results) => {
        if (err) {
          console.error(err);
          return res.status(500).json({ success: false });
        }
        res.json({ success: true, voteCount: results[0].voteCount });
      });
    });
  });
});

app.get('/tasks/schedule/voteDetails/:scheduleId', (req, res) => {
  const { scheduleId } = req.params;
  const query = `
    SELECT u.id as userId, u.display_name, u.profile_image 
    FROM schedule_votes sv 
    JOIN users u ON sv.user_id = u.id 
    WHERE sv.schedule_id = ?
  `;
  db.query(query, [scheduleId], (err, results) => {
    if (err) {
      console.error(err);
      return res.status(500).json({ success: false });
    }
    const details = results.map(row => ({
      userId: row.userId,
      displayName: row.display_name,
      profileImageBase64: row.profile_image ? Buffer.from(row.profile_image).toString('base64') : null
    }));
    res.json({ success: true, details });
  });
});

// ----------------------
// タスク参加者一覧
app.get('/tasks/participants/:taskId', (req, res) => {
  const { taskId } = req.params;
  const query = `
    SELECT u.id as userId, u.display_name, u.profile_image 
    FROM task_participants tp 
    JOIN users u ON tp.user_id = u.id 
    WHERE tp.task_id = ?
  `;
  db.query(query, [taskId], (err, results) => {
    if (err) {
      console.error(err);
      return res.status(500).json({ success: false });
    }
    const participants = results.map(row => ({
      userId: row.userId,
      displayName: row.display_name,
      profileImageBase64: row.profile_image ? Buffer.from(row.profile_image).toString('base64') : null
    }));
    res.json({ success: true, participants });
  });
});

// ----------------------
// タスクスケジュール確定
app.post('/tasks/schedule/finalize', (req, res) => {
  const { taskId, scheduleId } = req.body;
  if (!taskId || !scheduleId) {
    return res.status(400).json({ success: false, message: 'taskId と scheduleId は必須です。' });
  }
  const updateQuery = 'UPDATE task_schedules SET finalized = true WHERE id = ? AND task_id = ?';
  db.query(updateQuery, [scheduleId, taskId], (err, result) => {
    if (err) {
      console.error(err);
      return res.status(500).json({ success: false });
    }
    res.json({ success: true });
  });
});

const PORT = process.env.PORT || 3000;
//const HOST = '192.168.179.10';
const HOST = '172.18.104.114';

app.listen(PORT, HOST, () => {
  console.log(`サーバーは ${HOST}:${PORT} で起動中です。`);
});

-- ユーザーテーブル
CREATE TABLE users (
  id INT AUTO_INCREMENT PRIMARY KEY,
  username VARCHAR(50) NOT NULL UNIQUE,
  password VARCHAR(255) NOT NULL,
  display_name VARCHAR(100) NOT NULL,
  description TEXT,
  profile_image LONGBLOB,
  status VARCHAR(50) DEFAULT '進行中'
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- タスクテーブル
CREATE TABLE tasks (
  id INT AUTO_INCREMENT PRIMARY KEY,
  title VARCHAR(50) NOT NULL,
  description TEXT NOT NULL,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  creator_id INT,
  status VARCHAR(50) DEFAULT '進行中',
  FOREIGN KEY (creator_id) REFERENCES users(id) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- タスク参加テーブル
CREATE TABLE task_participants (
  id INT AUTO_INCREMENT PRIMARY KEY,
  task_id INT NOT NULL,
  user_id INT NOT NULL,
  FOREIGN KEY (task_id) REFERENCES tasks(id) ON DELETE CASCADE,
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- タスクスケジュールテーブル
CREATE TABLE task_schedules (
  id INT AUTO_INCREMENT PRIMARY KEY,
  task_id INT NOT NULL,
  scheduled_date DATETIME NOT NULL,
  schedule_description TEXT,
  finalized BOOLEAN DEFAULT false,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  registered_user_id INT,
  FOREIGN KEY (task_id) REFERENCES tasks(id) ON DELETE CASCADE,
  FOREIGN KEY (registered_user_id) REFERENCES users(id) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- スケジュール投票テーブル
CREATE TABLE schedule_votes (
  id INT AUTO_INCREMENT PRIMARY KEY,
  schedule_id INT NOT NULL,
  user_id INT NOT NULL,
  vote TINYINT,
  FOREIGN KEY (schedule_id) REFERENCES task_schedules(id) ON DELETE CASCADE,
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;



・タスクリストのタスク表示において、作成日時を2025年9月3日13:14と日本語にしたい

・タスクスケジュール管理において、日付範囲を入力すると思うが、
これがタスク表示になったときに、怪しくなる
具体的には、予定日時の表示が、設定した日付範囲の前日からになっている
また、予定日時において、終了時刻はどこにも表示されていない
この予定日時において、日付範囲を2025年9月3日13:14～2025年9月6日12:12と日本語にしたい
