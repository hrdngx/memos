@file:OptIn(ExperimentalMaterial3Api::class, ExperimentalPagerApi::class)

package com.example.taskun_app

import android.app.DatePickerDialog
import android.app.TimePickerDialog
import android.content.ContentValues.TAG
import android.content.Context
import android.graphics.Bitmap
import android.graphics.BitmapFactory
import android.net.Uri
import android.os.Bundle
import android.util.Base64
import android.util.Log
import androidx.activity.ComponentActivity
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.compose.setContent
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.animation.animateContentSize
import androidx.compose.foundation.BorderStroke
import androidx.compose.foundation.Image
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.grid.GridCells
import androidx.compose.foundation.lazy.grid.LazyVerticalGrid
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Add
import androidx.compose.material.icons.filled.ArrowBack
import androidx.compose.material.icons.filled.ArrowForward
import androidx.compose.material.icons.filled.ExitToApp
import androidx.compose.material.icons.filled.Info
import androidx.compose.material.icons.filled.List
import androidx.compose.material.icons.filled.Person
import androidx.compose.material3.*
import androidx.compose.material3.SnackbarHostState
import androidx.compose.material3.SnackbarHost
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.asImageBitmap
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.input.ImeAction
import androidx.compose.ui.text.input.PasswordVisualTransformation
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProvider
import androidx.lifecycle.viewModelScope
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavHostController
import androidx.navigation.compose.NavHost
import androidx.navigation.compose.composable
import androidx.navigation.compose.currentBackStackEntryAsState
import androidx.navigation.compose.rememberNavController
import com.google.accompanist.pager.ExperimentalPagerApi
import com.google.gson.annotations.SerializedName
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import retrofit2.Retrofit
import retrofit2.converter.gson.GsonConverterFactory
import retrofit2.http.Body
import retrofit2.http.GET
import retrofit2.http.POST
import retrofit2.http.Path
import retrofit2.http.Query
import java.text.SimpleDateFormat
import java.util.*

// ─── DATA CLASSES & API DEFINITIONS ─────────────────────────────────────────────

// 改修：TaskData に投票数と正式決定フラグを追加
data class TaskData(
    @SerializedName("id") val id: Int,
    @SerializedName("title") val title: String,
    @SerializedName("description") val description: String,
    @SerializedName("created_at") val createdAt: String,
    @SerializedName("creatorDisplayName") val creatorDisplayName: String,
    @SerializedName("creatorProfileImage") val creatorProfileImage: String?,
    @SerializedName("creatorId") val creatorId: Int,
    @SerializedName("status") val status: String,
    @SerializedName("totalVotes") val totalVotes: Int? = 0,
    @SerializedName("isFinalized") val isFinalized: Boolean? = false
)
data class TaskListResponse(val success: Boolean, val tasks: List<TaskData>)

data class RegisterRequest(val username: String, val password: String, val displayName: String)
data class RegisterResponse(val success: Boolean, val token: String?, val userId: Int?)
data class LoginRequest(val username: String, val password: String)
data class LoginResponse(val success: Boolean, val token: String?, val userId: Int?)
data class TaskCreationRequest(val userId: Int, val title: String, val description: String)
data class TaskCreationResponse(val success: Boolean, val taskId: Int?)
data class TaskJoinRequest(val userId: Int, val taskId: Int)
data class TaskJoinResponse(val success: Boolean)
data class TaskEditRequest(val taskId: Int, val title: String, val description: String)
data class TaskEditResponse(val success: Boolean)
data class TaskCompleteRequest(val taskId: Int)
data class TaskCompleteResponse(val success: Boolean)

// 以下、プロフィール・スケジュール・投票等のデータクラスはそのまま…

// ─── RETROFIT & SESSION MANAGER ───────────────────────────────────────────────

interface ApiService {
    @POST("register")
    suspend fun register(@Body request: RegisterRequest): RegisterResponse

    @POST("login")
    suspend fun login(@Body request: LoginRequest): LoginResponse

    @POST("tasks")
    suspend fun createTask(@Body request: TaskCreationRequest): TaskCreationResponse

    @POST("tasks/join")
    suspend fun joinTask(@Body request: TaskJoinRequest): TaskJoinResponse

    // 改修：getTasks にオプションのクエリパラメータ sort を追加
    @GET("tasks")
    suspend fun getTasks(@Query("sort") sort: String? = null): TaskListResponse

    @POST("tasks/edit")
    suspend fun editTask(@Body request: TaskEditRequest): TaskEditResponse

    @POST("tasks/complete")
    suspend fun completeTask(@Body request: TaskCompleteRequest): TaskCompleteResponse

    // 以下、プロフィール／スケジュール／投票などのAPI定義はそのまま…
    // …
}

object RetrofitClient {
    private const val BASE_URL = "http://172.18.12.114:3000/"
    val apiService: ApiService by lazy {
        Retrofit.Builder()
            .baseUrl(BASE_URL)
            .addConverterFactory(GsonConverterFactory.create())
            .build()
            .create(ApiService::class.java)
    }
}

class SessionManager(context: Context) {
    private val prefs = context.getSharedPreferences("taskun_prefs", Context.MODE_PRIVATE)
    companion object {
        private const val KEY_TOKEN = "key_token"
        private const val KEY_USER_ID = "key_user_id"
    }
    fun saveAuthToken(token: String) { prefs.edit().putString(KEY_TOKEN, token).apply() }
    fun fetchAuthToken(): String? = prefs.getString(KEY_TOKEN, null)
    fun saveUserId(userId: Int) { prefs.edit().putInt(KEY_USER_ID, userId).apply() }
    fun fetchUserId(): Int = prefs.getInt(KEY_USER_ID, -1)
    fun clearSession() { prefs.edit().remove(KEY_TOKEN).remove(KEY_USER_ID).apply() }
}

// ─── HELPER FUNCTIONS ───────────────────────────────────────────

fun decodeBase64ToBitmap(base64String: String): Bitmap? {
    return try {
        val decodedBytes = Base64.decode(base64String, Base64.DEFAULT)
        BitmapFactory.decodeByteArray(decodedBytes, 0, decodedBytes.size)
    } catch (e: Exception) {
        Log.e(TAG, "Error decoding base64", e)
        null
    }
}

fun combineDateTime(date: Date, timeStr: String): Date {
    val calendar = Calendar.getInstance().apply { time = date }
    val parts = timeStr.split(":")
    if (parts.size >= 2) {
        calendar.set(Calendar.HOUR_OF_DAY, parts[0].toInt())
        calendar.set(Calendar.MINUTE, parts[1].toInt())
        calendar.set(Calendar.SECOND, 0)
    }
    return calendar.time
}

fun formatDate(date: Date): String {
    return SimpleDateFormat("yyyy/MM/dd", Locale.getDefault()).format(date)
}

fun formatJapaneseDateTime(date: Date): String {
    return SimpleDateFormat("yyyy年M月d日 HH時mm分", Locale.JAPAN).format(date)
}

fun formatCreatedAtJapanese(createdAt: String): String {
    return try {
        val parser = SimpleDateFormat("yyyy-MM-dd'T'HH-mm:ss.SSS'Z'", Locale.getDefault())
        parser.timeZone = TimeZone.getTimeZone("UTC")
        val date = parser.parse(createdAt)
        if (date != null) {
            val formatter = SimpleDateFormat("yyyy年M月d日'('E')'", Locale.JAPAN)
            formatter.format(date)
        } else {
            createdAt
        }
    } catch (e: Exception) {
        Log.e(TAG, "日付のパースエラー", e)
        createdAt
    }
}

data class DateRange(val start: Date, val end: Date)

// ─── LIGHT THEME ───────────────────────────────────────────────

private val LightColorScheme = lightColorScheme(
    primary = Color(0xFF1976D2),
    onPrimary = Color.White,
    secondary = Color(0xFF90CAF9),
    onSecondary = Color.Black,
    background = Color.White,
    onBackground = Color.Black,
    surface = Color.White,
    onSurface = Color.Black
)

@Composable
fun LightTaskunTheme(content: @Composable () -> Unit) {
    MaterialTheme(
        colorScheme = LightColorScheme,
        typography = Typography(
            headlineLarge = TextStyle(fontSize = 30.sp, fontWeight = FontWeight.Bold),
            headlineMedium = TextStyle(fontSize = 24.sp, fontWeight = FontWeight.SemiBold),
            bodyLarge = TextStyle(fontSize = 18.sp),
            bodyMedium = TextStyle(fontSize = 16.sp)
        ),
        shapes = Shapes(
            small = RoundedCornerShape(8.dp),
            medium = RoundedCornerShape(12.dp),
            large = RoundedCornerShape(16.dp)
        ),
        content = content
    )
}

// ─── 共通コンポーザブル：プロフィール画像 ─────────────────────────

@Composable
fun ProfileImage(base64String: String, modifier: Modifier = Modifier) {
    val bitmap = remember(base64String) { decodeBase64ToBitmap(base64String) }
    if (bitmap != null) {
        Image(
            bitmap = bitmap.asImageBitmap(),
            contentDescription = "Profile Image",
            modifier = modifier
                .clip(CircleShape)
                .border(2.dp, LightColorScheme.primary, CircleShape),
            contentScale = ContentScale.Crop
        )
    } else {
        Icon(
            imageVector = Icons.Filled.Person,
            contentDescription = "Default Profile",
            modifier = modifier
        )
    }
}

@Composable
fun ProfileImagePreview(base64String: String) {
    if (base64String.isNotEmpty()) {
        ProfileImage(base64String, modifier = Modifier.size(100.dp))
    } else {
        Box(
            modifier = Modifier
                .size(100.dp)
                .clip(CircleShape)
                .border(2.dp, LightColorScheme.primary, CircleShape),
            contentAlignment = Alignment.Center
        ) {
            Icon(
                imageVector = Icons.Filled.Person,
                contentDescription = "Select Profile Image",
                modifier = Modifier.size(50.dp)
            )
        }
    }
}

// ─── 時刻選択ボタン ───────────────────────────────

@Composable
fun TimePickerButton(label: String, time: String, onTimeSelected: (String) -> Unit) {
    val context = LocalContext.current
    ElevatedButton(
        onClick = {
            val calendar = Calendar.getInstance()
            val hour = calendar.get(Calendar.HOUR_OF_DAY)
            val minute = calendar.get(Calendar.MINUTE)
            TimePickerDialog(context, { _, selectedHour, selectedMinute ->
                onTimeSelected(String.format("%02d:%02d", selectedHour, selectedMinute))
            }, hour, minute, true).show()
        },
        modifier = Modifier.fillMaxWidth()
    ) {
        Text("$label: $time")
    }
}

// ─── 改良カレンダー（左右の矢印付き） ─────────────────────────

@Composable
fun ImprovedCalendar(
    initialYear: Int = Calendar.getInstance().get(Calendar.YEAR),
    initialMonth: Int = Calendar.getInstance().get(Calendar.MONTH),
    selectedRange: DateRange?,
    onRangeSelected: (DateRange) -> Unit
) {
    var currentYear by remember { mutableStateOf(initialYear) }
    var currentMonth by remember { mutableStateOf(initialMonth) }
    var tempStartDate by remember { mutableStateOf<Date?>(null) }
    Column(
        modifier = Modifier
            .fillMaxWidth()
            .padding(8.dp)
            .background(
                brush = Brush.horizontalGradient(listOf(Color.White, LightColorScheme.background)),
                shape = RoundedCornerShape(12.dp)
            )
            .padding(8.dp)
    ) {
        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.SpaceBetween,
            verticalAlignment = Alignment.CenterVertically
        ) {
            IconButton(onClick = {
                val cal = Calendar.getInstance().apply { set(currentYear, currentMonth, 1) }
                cal.add(Calendar.MONTH, -1)
                currentYear = cal.get(Calendar.YEAR)
                currentMonth = cal.get(Calendar.MONTH)
            }) {
                Icon(Icons.Filled.ArrowBack, contentDescription = "前月")
            }
            Text(text = "$currentYear 年 ${currentMonth + 1}月", style = MaterialTheme.typography.headlineSmall)
            IconButton(onClick = {
                val cal = Calendar.getInstance().apply { set(currentYear, currentMonth, 1) }
                cal.add(Calendar.MONTH, 1)
                currentYear = cal.get(Calendar.YEAR)
                currentMonth = cal.get(Calendar.MONTH)
            }) {
                Icon(Icons.Filled.ArrowForward, contentDescription = "次月")
            }
        }
        val calendar = Calendar.getInstance().apply { set(currentYear, currentMonth, 1) }
        val daysInMonth = calendar.getActualMaximum(Calendar.DAY_OF_MONTH)
        val firstDayOfWeek = calendar.get(Calendar.DAY_OF_WEEK)
        val days = (1..daysInMonth).map { day ->
            calendar.apply { set(currentYear, currentMonth, day) }
            calendar.time
        }
        LazyVerticalGrid(
            columns = GridCells.Fixed(7),
            modifier = Modifier.height(250.dp)
        ) {
            items(firstDayOfWeek - 1) { Box(modifier = Modifier.aspectRatio(1f)) }
            items(days.size) { index ->
                val day = days[index]
                val isSelected = selectedRange?.let { !day.before(it.start) && !day.after(it.end) } ?: false
                Box(
                    modifier = Modifier
                        .aspectRatio(1f)
                        .padding(2.dp)
                        .clickable {
                            if (tempStartDate == null) {
                                tempStartDate = day
                            } else {
                                val start = if (day.before(tempStartDate)) day else tempStartDate!!
                                val end = if (day.before(tempStartDate)) tempStartDate!! else day
                                onRangeSelected(DateRange(start, end))
                                tempStartDate = null
                            }
                        }
                        .background(
                            if (isSelected) LightColorScheme.primary.copy(alpha = 0.5f) else Color.Transparent,
                            shape = RoundedCornerShape(6.dp)
                        ),
                    contentAlignment = Alignment.Center
                ) {
                    Text(
                        text = SimpleDateFormat("d", Locale.getDefault()).format(day),
                        color = if (isSelected) Color.White else LightColorScheme.onBackground
                    )
                }
            }
        }
    }
}

// ─── 各種画面 ──────────────────────────────────────────────────────────────

@Composable
fun RegistrationScreen(navController: NavHostController, sessionManager: SessionManager, snackbarHostState: SnackbarHostState) {
    var username by remember { mutableStateOf("") }
    var password by remember { mutableStateOf("") }
    var displayName by remember { mutableStateOf("") }
    var isLoading by remember { mutableStateOf(false) }
    val coroutineScope = rememberCoroutineScope()
    Box(modifier = Modifier.fillMaxSize().background(Color.White)) {
        Card(
            modifier = Modifier.fillMaxWidth().padding(24.dp).align(Alignment.Center).animateContentSize(),
            shape = RoundedCornerShape(16.dp),
            elevation = CardDefaults.cardElevation(8.dp)
        ) {
            Column(modifier = Modifier.padding(24.dp).verticalScroll(rememberScrollState())) {
                Text(text = "たすくん", style = MaterialTheme.typography.headlineLarge)
                Spacer(modifier = Modifier.height(16.dp))
                OutlinedTextField(
                    value = username,
                    onValueChange = { username = it },
                    label = { Text("ユーザーネーム") },
                    singleLine = true,
                    modifier = Modifier.fillMaxWidth(),
                    isError = username.isBlank()
                )
                if (username.isBlank()) {
                    Text("ユーザーネームは必須です", style = MaterialTheme.typography.labelSmall, color = Color.Red)
                }
                Spacer(modifier = Modifier.height(8.dp))
                OutlinedTextField(
                    value = password,
                    onValueChange = { password = it },
                    label = { Text("パスワード (6文字以上)") },
                    visualTransformation = PasswordVisualTransformation(),
                    singleLine = true,
                    modifier = Modifier.fillMaxWidth(),
                    keyboardOptions = KeyboardOptions(imeAction = ImeAction.Next),
                    isError = password.length < 6
                )
                if (password.length < 6) {
                    Text("パスワードは6文字以上必要です", style = MaterialTheme.typography.labelSmall, color = Color.Red)
                }
                Spacer(modifier = Modifier.height(8.dp))
                OutlinedTextField(
                    value = displayName,
                    onValueChange = { displayName = it },
                    label = { Text("表示名") },
                    singleLine = true,
                    modifier = Modifier.fillMaxWidth(),
                    isError = displayName.isBlank()
                )
                if (displayName.isBlank()) {
                    Text("表示名は必須です", style = MaterialTheme.typography.labelSmall, color = Color.Red)
                }
                Spacer(modifier = Modifier.height(16.dp))
                ElevatedButton(
                    onClick = {
                        if (username.isBlank() || password.length < 6 || displayName.isBlank()) {
                            coroutineScope.launch { snackbarHostState.showSnackbar("入力内容を確認してください。") }
                            return@ElevatedButton
                        }
                        isLoading = true
                        coroutineScope.launch {
                            try {
                                val response = RetrofitClient.apiService.register(RegisterRequest(username, password, displayName))
                                if (response.success && response.token != null && response.userId != null) {
                                    sessionManager.saveAuthToken(response.token)
                                    sessionManager.saveUserId(response.userId)
                                    navController.navigate("main") { popUpTo("register") { inclusive = true } }
                                } else {
                                    snackbarHostState.showSnackbar("登録に失敗しました。")
                                }
                            } catch (e: Exception) {
                                Log.e(TAG, "Registration error", e)
                                snackbarHostState.showSnackbar("サーバーエラーが発生しました。")
                            } finally {
                                isLoading = false
                            }
                        }
                    },
                    modifier = Modifier.fillMaxWidth(),
                    enabled = !isLoading
                ) {
                    Text("会員登録")
                }
                Spacer(modifier = Modifier.height(16.dp))
                Text(
                    text = "既に登録済みの方はこちら",
                    style = MaterialTheme.typography.bodyMedium,
                    color = LightColorScheme.primary,
                    modifier = Modifier.clickable { navController.navigate("login") { popUpTo("register") { inclusive = true } } }
                )
            }
        }
    }
}

@Composable
fun LoginScreen(navController: NavHostController, sessionManager: SessionManager, snackbarHostState: SnackbarHostState) {
    var username by remember { mutableStateOf("") }
    var password by remember { mutableStateOf("") }
    var isLoading by remember { mutableStateOf(false) }
    val coroutineScope = rememberCoroutineScope()
    Box(modifier = Modifier.fillMaxSize().background(Color.White)) {
        Card(
            modifier = Modifier.fillMaxWidth().padding(24.dp).align(Alignment.Center).animateContentSize(),
            shape = RoundedCornerShape(16.dp),
            elevation = CardDefaults.cardElevation(8.dp)
        ) {
            Column(modifier = Modifier.padding(24.dp).verticalScroll(rememberScrollState())) {
                Text(text = "たすくん", style = MaterialTheme.typography.headlineLarge)
                Spacer(modifier = Modifier.height(16.dp))
                OutlinedTextField(
                    value = username,
                    onValueChange = { username = it },
                    label = { Text("ユーザーネーム") },
                    singleLine = true,
                    modifier = Modifier.fillMaxWidth()
                )
                Spacer(modifier = Modifier.height(8.dp))
                OutlinedTextField(
                    value = password,
                    onValueChange = { password = it },
                    label = { Text("パスワード") },
                    visualTransformation = PasswordVisualTransformation(),
                    singleLine = true,
                    modifier = Modifier.fillMaxWidth()
                )
                Spacer(modifier = Modifier.height(16.dp))
                ElevatedButton(
                    onClick = {
                        isLoading = true
                        coroutineScope.launch {
                            try {
                                val response = RetrofitClient.apiService.login(LoginRequest(username, password))
                                if (response.success && response.token != null && response.userId != null) {
                                    sessionManager.saveAuthToken(response.token)
                                    sessionManager.saveUserId(response.userId)
                                    navController.navigate("main") { popUpTo("login") { inclusive = true } }
                                } else {
                                    snackbarHostState.showSnackbar("ユーザ名またはパスワードが正しくありません。")
                                }
                            } catch (e: Exception) {
                                Log.e(TAG, "Login error", e)
                                snackbarHostState.showSnackbar("サーバーエラーが発生しました。")
                            } finally {
                                isLoading = false
                            }
                        }
                    },
                    modifier = Modifier.fillMaxWidth(),
                    enabled = !isLoading
                ) {
                    Text("ログイン")
                }
                Spacer(modifier = Modifier.height(16.dp))
                Text(
                    text = "新規登録していない人はこちら",
                    color = LightColorScheme.primary,
                    modifier = Modifier.fillMaxWidth().clickable { navController.navigate("register") },
                    textAlign = androidx.compose.ui.text.style.TextAlign.Center
                )
            }
        }
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun MainScreen(userId: Int, sessionManager: SessionManager, outerNavController: NavHostController, snackbarHostState: SnackbarHostState) {
    val innerNavController = rememberNavController()
    Scaffold(
        topBar = {
            CenterAlignedTopAppBar(
                title = { Text("たすくん") },
                actions = {
                    IconButton(onClick = {
                        sessionManager.clearSession()
                        outerNavController.navigate("login") { popUpTo("main") { inclusive = true } }
                    }) {
                        Icon(Icons.Filled.ExitToApp, contentDescription = "Logout")
                    }
                },
                colors = TopAppBarDefaults.centerAlignedTopAppBarColors(containerColor = LightColorScheme.primary)
            )
        },
        bottomBar = { BottomNavigationBar(innerNavController) },
        snackbarHost = { SnackbarHost(hostState = snackbarHostState) },
        containerColor = LightColorScheme.background
    ) { innerPadding ->
        NavHost(navController = innerNavController, startDestination = "instruction", modifier = Modifier.padding(innerPadding)) {
            composable("instruction") { InstructionScreen(innerNavController) }
            composable("taskList") { TaskListScreen(innerNavController, userId, snackbarHostState) }
            composable("taskRegistration") { TaskRegistrationScreen(userId, snackbarHostState) }
            composable("profileRegistration") { ProfileRegistrationScreen(userId, snackbarHostState) }
            composable("profileView/{userId}") { backStackEntry ->
                val profileUserId = backStackEntry.arguments?.getString("userId")?.toInt() ?: 0
                UserProfileScreen(profileUserId, snackbarHostState)
            }
            composable("taskEdit/{taskId}") { backStackEntry ->
                val taskId = backStackEntry.arguments?.getString("taskId")?.toInt() ?: 0
                TaskEditScreen(taskId, innerNavController, snackbarHostState)
            }
            composable("scheduleEdit/{scheduleId}") { backStackEntry ->
                val scheduleId = backStackEntry.arguments?.getString("scheduleId")?.toInt() ?: 0
                ScheduleEditScreen(scheduleId, innerNavController, snackbarHostState)
            }
            composable("taskParticipants/{taskId}") { backStackEntry ->
                val taskId = backStackEntry.arguments?.getString("taskId")?.toInt() ?: 0
                TaskParticipantsScreen(taskId, innerNavController, snackbarHostState)
            }
            composable("taskScheduleManagement/{taskId}") { backStackEntry ->
                val taskId = backStackEntry.arguments?.getString("taskId")?.toInt() ?: 0
                TaskScheduleManagementScreen(taskId, innerNavController, sessionManager.fetchUserId(), snackbarHostState)
            }
        }
    }
}

sealed class Screen(val route: String, val label: String, val icon: @Composable () -> Unit) {
    object Instruction : Screen("instruction", "使い方", { Icon(Icons.Filled.Info, contentDescription = null) })
    object TaskList : Screen("taskList", "タスクリスト", { Icon(Icons.Filled.List, contentDescription = null) })
    object TaskRegistration : Screen("taskRegistration", "タスク登録", { Icon(Icons.Filled.Add, contentDescription = null) })
    object ProfileRegistration : Screen("profileRegistration", "プロフィール", { Icon(Icons.Filled.Person, contentDescription = null) })
}

@Composable
fun BottomNavigationBar(navController: NavHostController) {
    val items = listOf(Screen.Instruction, Screen.TaskList, Screen.TaskRegistration, Screen.ProfileRegistration)
    val navBackStackEntry by navController.currentBackStackEntryAsState()
    val currentRoute = navBackStackEntry?.destination?.route
    NavigationBar {
        items.forEach { screen ->
            NavigationBarItem(
                icon = screen.icon,
                label = { Text(screen.label) },
                selected = currentRoute?.startsWith(screen.route.substringBefore("/")) == true,
                onClick = {
                    navController.navigate(screen.route) {
                        popUpTo(navController.graph.startDestinationId) { saveState = true }
                        launchSingleTop = true
                        restoreState = true
                    }
                }
            )
        }
    }
}

@Composable
fun InstructionScreen(navController: NavHostController) {
    Box(modifier = Modifier.fillMaxSize().background(Color.White), contentAlignment = Alignment.Center) {
        Card(
            modifier = Modifier.padding(24.dp),
            shape = RoundedCornerShape(16.dp),
            elevation = CardDefaults.cardElevation(8.dp)
        ) {
            Column(modifier = Modifier.padding(24.dp), horizontalAlignment = Alignment.CenterHorizontally) {
                Text("使い方の説明", style = MaterialTheme.typography.headlineMedium)
                Spacer(modifier = Modifier.height(16.dp))
                Text(
                    "・タスク登録画面でタスクを作成し、スケジュール登録・投票で実施日時を決定します。\n" +
                    "・タスク一覧では、タスク作成者のプロフィールをタップすると詳細が見られます。\n" +
                    "・タスク編集、スケジュール管理、参加者一覧などの機能を実装しています。",
                    style = MaterialTheme.typography.bodyLarge,
                    textAlign = androidx.compose.ui.text.style.TextAlign.Center
                )
                Spacer(modifier = Modifier.height(24.dp))
                ElevatedButton(onClick = { navController.navigate("taskList") }, modifier = Modifier.fillMaxWidth()) {
                    Text("タスクリストへ進む")
                }
            }
        }
    }
}

@Composable
fun TaskListScreen(navController: NavHostController, userId: Int, snackbarHostState: SnackbarHostState) {
    // sortOrder に「投票が多い順」を追加
    var sortOrder by remember { mutableStateOf("新しい順") }
    var filterStatus by remember { mutableStateOf("全て") }
    var tasks by remember { mutableStateOf(listOf<TaskData>()) }
    var isLoading by remember { mutableStateOf(true) }
    var errorMessage by remember { mutableStateOf("") }
    var joinedTaskIds by remember { mutableStateOf(setOf<Int>()) }
    val coroutineScope = rememberCoroutineScope()

    // sortOrderが変更されたときにも再読み込みするため key に sortOrder を指定
    LaunchedEffect(sortOrder) {
        while (true) {
            try {
                // sortOrder が「投票が多い順」の場合、APIに sort=votes を指定
                val response = if (sortOrder == "投票が多い順")
                    RetrofitClient.apiService.getTasks("votes")
                else
                    RetrofitClient.apiService.getTasks(null)
                if (response.success) {
                    // 「古い順」はサーバーの新着順結果を反転
                    tasks = if (sortOrder == "古い順") response.tasks.reversed() else response.tasks
                    errorMessage = ""
                } else {
                    errorMessage = "タスク取得に失敗しました。"
                }
            } catch (e: Exception) {
                errorMessage = "サーバーに接続できません。"
                Log.e(TAG, "タスク取得エラー", e)
            } finally {
                isLoading = false
            }
            delay(5000)
        }
    }

    Column(modifier = Modifier.fillMaxSize().background(LightColorScheme.background)) {
        Row(
            modifier = Modifier.fillMaxWidth().padding(horizontal = 16.dp, vertical = 8.dp),
            horizontalArrangement = Arrangement.SpaceBetween
        ) {
            DropdownMenuBox(
                label = "並び順",
                options = listOf("新しい順", "古い順", "投票が多い順"),
                selectedOption = sortOrder
            ) { sortOrder = it }
            DropdownMenuBox(
                label = "ステータス",
                options = listOf("全て", "進行中", "完了済み"),
                selectedOption = filterStatus
            ) { filterStatus = it }
        }
        Spacer(modifier = Modifier.height(8.dp))
        if (isLoading) {
            Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
                CircularProgressIndicator()
            }
        } else {
            if (errorMessage.isNotEmpty()) {
                Text(
                    text = errorMessage,
                    modifier = Modifier.align(Alignment.CenterHorizontally),
                    color = Color.Red
                )
            } else {
                LazyColumn(
                    modifier = Modifier.fillMaxSize().padding(horizontal = 16.dp)
                ) {
                    items(tasks.filter { task ->
                        filterStatus == "全て" || task.status == filterStatus
                    }) { task ->
                        Card(
                            modifier = Modifier
                                .fillMaxWidth()
                                .padding(vertical = 8.dp)
                                .clickable { /* タスク詳細画面への遷移 */ },
                            shape = RoundedCornerShape(16.dp),
                            elevation = CardDefaults.cardElevation(8.dp),
                            colors = CardDefaults.cardColors(containerColor = Color.White)
                        ) {
                            Column(modifier = Modifier.padding(16.dp)) {
                                // プロフィール画像とユーザー名
                                Row(verticalAlignment = Alignment.CenterVertically) {
                                    if (task.creatorProfileImage != null) {
                                        ProfileImage(
                                            base64String = task.creatorProfileImage,
                                            modifier = Modifier.size(48.dp).clip(CircleShape).border(2.dp, LightColorScheme.primary, CircleShape)
                                        )
                                    } else {
                                        Icon(
                                            imageVector = Icons.Filled.Person,
                                            contentDescription = "Profile",
                                            modifier = Modifier.size(48.dp)
                                        )
                                    }
                                    Spacer(modifier = Modifier.width(8.dp))
                                    Text(
                                        text = task.creatorDisplayName,
                                        style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.Bold, color = LightColorScheme.primary)
                                    )
                                }
                                Divider(modifier = Modifier.padding(vertical = 4.dp))
                                // タスク名
                                Text(
                                    text = "タスク名: ${task.title}",
                                    style = MaterialTheme.typography.titleLarge.copy(fontWeight = FontWeight.ExtraBold)
                                )
                                Divider(modifier = Modifier.padding(vertical = 4.dp))
                                // タスクの説明
                                Text("タスクの説明", style = MaterialTheme.typography.labelMedium)
                                Text(task.description, style = MaterialTheme.typography.bodyMedium)
                                Divider(modifier = Modifier.padding(vertical = 4.dp))
                                // 作成日時とステータス、投票数表示（sortが「投票が多い順」の場合）
                                Row(
                                    modifier = Modifier.fillMaxWidth(),
                                    horizontalArrangement = Arrangement.SpaceBetween
                                ) {
                                    Column {
                                        Text("作成日時", style = MaterialTheme.typography.labelSmall.copy(color = LightColorScheme.primary))
                                        Text(formatCreatedAtJapanese(task.createdAt), style = MaterialTheme.typography.bodySmall, color = Color.Gray)
                                    }
                                    Column(horizontalAlignment = Alignment.End) {
                                        Text("ステータス", style = MaterialTheme.typography.labelSmall.copy(color = LightColorScheme.primary))
                                        Text(
                                            task.status,
                                            style = MaterialTheme.typography.bodySmall,
                                            color = if (task.status == "完了済み") Color(0xFF388E3C) else LightColorScheme.primary
                                        )
                                    }
                                }
                                // 投票数（sortが「投票が多い順」の場合）および正式決定ラベルの表示
                                if (sortOrder == "投票が多い順") {
                                    Spacer(modifier = Modifier.height(4.dp))
                                    Row(modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceBetween) {
                                        Text("投票数: ${task.totalVotes ?: 0}", style = MaterialTheme.typography.bodySmall)
                                        if (task.isFinalized == true) {
                                            Text("【正式決定済み】", style = MaterialTheme.typography.bodySmall.copy(color = Color.Red, fontWeight = FontWeight.Bold))
                                        }
                                    }
                                }
                                Divider(modifier = Modifier.padding(vertical = 4.dp))
                                // タスク参加／管理ボタン
                                if (userId == task.creatorId) {
                                    Row(
                                        modifier = Modifier.fillMaxWidth(),
                                        horizontalArrangement = Arrangement.SpaceEvenly
                                    ) {
                                        ElevatedButton(onClick = { navController.navigate("taskEdit/${task.id}") }) {
                                            Text("タスク編集")
                                        }
                                        ElevatedButton(onClick = { navController.navigate("taskScheduleManagement/${task.id}") }) {
                                            Text("スケジュール管理")
                                        }
                                    }
                                } else {
                                    if (joinedTaskIds.contains(task.id)) {
                                        ElevatedButton(
                                            onClick = { navController.navigate("taskScheduleManagement/${task.id}") },
                                            modifier = Modifier.fillMaxWidth()
                                        ) {
                                            Text("参加済み")
                                        }
                                    } else {
                                        ElevatedButton(
                                            onClick = {
                                                coroutineScope.launch {
                                                    try {
                                                        val joinResponse = RetrofitClient.apiService.joinTask(TaskJoinRequest(userId, task.id))
                                                        if (joinResponse.success) {
                                                            joinedTaskIds = joinedTaskIds + task.id
                                                            navController.navigate("taskScheduleManagement/${task.id}")
                                                        } else {
                                                            snackbarHostState.showSnackbar("タスク参加に失敗しました")
                                                        }
                                                    } catch (e: Exception) {
                                                        Log.e(TAG, "タスク参加処理でエラー", e)
                                                    }
                                                }
                                            },
                                            modifier = Modifier.fillMaxWidth()
                                        ) {
                                            Text("タスク参加")
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

@Composable
fun DropdownMenuBox(label: String, options: List<String>, selectedOption: String, onOptionSelected: (String) -> Unit) {
    var expanded by remember { mutableStateOf(false) }
    Box {
        OutlinedButton(onClick = { expanded = true }) {
            Text("$label: $selectedOption")
        }
        DropdownMenu(expanded = expanded, onDismissRequest = { expanded = false }) {
            options.forEach { option ->
                DropdownMenuItem(text = { Text(option) }, onClick = { onOptionSelected(option); expanded = false })
            }
        }
    }
}

// 以下、TaskRegistrationScreen, ProfileRegistrationScreen, UserProfileScreen, TaskEditScreen,
// ScheduleEditScreen, TaskScheduleManagementScreen, TaskParticipantsScreen などは基本的には従来通り実装
// （必要に応じて正式決定／投票数に関連する表示を追加する）
// …

// ─── MainActivity ─────────────────────────────────────────────

class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        val sessionManager = SessionManager(applicationContext)
        setContent {
            LightTaskunTheme {
                val navController = rememberNavController()
                val snackbarHostState = remember { SnackbarHostState() }
                val startDestination = if (sessionManager.fetchAuthToken() != null) "main" else "register"
                NavHost(navController = navController, startDestination = startDestination) {
                    composable("register") { RegistrationScreen(navController, sessionManager, snackbarHostState) }
                    composable("login") { LoginScreen(navController, sessionManager, snackbarHostState) }
                    composable("main") {
                        MainScreen(userId = sessionManager.fetchUserId(), sessionManager = sessionManager,
                            outerNavController = navController, snackbarHostState = snackbarHostState)
                    }
                    composable("taskEdit/{taskId}") { backStackEntry ->
                        val taskId = backStackEntry.arguments?.getString("taskId")?.toInt() ?: 0
                        TaskEditScreen(taskId, navController, snackbarHostState)
                    }
                    composable("scheduleEdit/{scheduleId}") { backStackEntry ->
                        val scheduleId = backStackEntry.arguments?.getString("scheduleId")?.toInt() ?: 0
                        ScheduleEditScreen(scheduleId, navController, snackbarHostState)
                    }
                    composable("taskParticipants/{taskId}") { backStackEntry ->
                        val taskId = backStackEntry.arguments?.getString("taskId")?.toInt() ?: 0
                        TaskParticipantsScreen(taskId, navController, snackbarHostState)
                    }
                    composable("taskScheduleManagement/{taskId}") { backStackEntry ->
                        val taskId = backStackEntry.arguments?.getString("taskId")?.toInt() ?: 0
                        TaskScheduleManagementScreen(taskId, navController, sessionManager.fetchUserId(), snackbarHostState)
                    }
                    composable("taskRegistration") { TaskRegistrationScreen(sessionManager.fetchUserId(), snackbarHostState) }
                    composable("profileRegistration") { ProfileRegistrationScreen(sessionManager.fetchUserId(), snackbarHostState) }
                    composable("profileView/{userId}") { backStackEntry ->
                        val profileUserId = backStackEntry.arguments?.getString("userId")?.toInt() ?: 0
                        UserProfileScreen(profileUserId, snackbarHostState)
                    }
                    composable("instruction") { InstructionScreen(navController) }
                }
            }
        }
    }
}